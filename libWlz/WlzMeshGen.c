#if defined(__GNUC__)
#ident "University of Edinburgh $Id$"
#else
static char _WlzMeshGen_c[] = "University of Edinburgh $Id$";
#endif
/*!
* \file         libWlz/WlzMeshGen.c
* \author       Bill Hill
* \date         June 2003
* \version      $Id$
* \par
* Address:
*               MRC Human Genetics Unit,
*               MRC Institute of Genetics and Molecular Medicine,
*               University of Edinburgh,
*               Western General Hospital,
*               Edinburgh, EH4 2XU, UK.
* \par
* Copyright (C), [2012],
* The University Court of the University of Edinburgh,
* Old College, Edinburgh, UK.
* 
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be
* useful but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
* PURPOSE.  See the GNU General Public License for more
* details.
*
* You should have received a copy of the GNU General Public
* License along with this program; if not, write to the Free
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA  02110-1301, USA.
* \brief	Functions for 2D and 3D conforming simplical mesh generation.
* 		Meshes generated by these functions will conform approximately
* 		to an objects boundaries.
*
* \ingroup	WlzMesh
*/
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <Wlz.h>

#ifndef WLZ_FAST_CODE
#define WLZ_FAST_CODE
#endif

/*!
* \enum		_WlzCMeshConformAction
* \ingroup	WlzMesh
* \brief	Possible mesh element conformation actions.
* 		Typedef: ::WlzCMeshConformAction.
*/
typedef enum _WlzCMeshConformAction
{
  WLZ_CMESH_CONFORM_NONE,
  WLZ_CMESH_CONFORM_DELETE,
  WLZ_CMESH_CONFORM_MODIFY
} WlzCMeshConformAction;

static void	  		WlzCMeshFreeGridCells2D(
				  WlzCMesh2D *mesh);
static void	  		WlzCMeshFreeGridCells2D5(
				  WlzCMesh2D5 *mesh);
static void	  		WlzCMeshFreeGridCells3D(
				  WlzCMesh3D *mesh);
static void			WlzCMeshAddNodToGrid2D(
				  WlzCMesh2D *mesh,
				  WlzCMeshNod2D *nod);
static void			WlzCMeshAddNodToGrid2D5(
				  WlzCMesh2D5 *mesh,
				  WlzCMeshNod2D5 *nod);
static void			WlzCMeshAddNodToGrid3D(
				  WlzCMesh3D *mesh,
				  WlzCMeshNod3D *nod);
static void			WlzCMeshRemNodFromGrid2D(
				  WlzCMesh2D *mesh,
				  WlzCMeshNod2D *nod);
static void			WlzCMeshRemNodFromGrid2D5(
				  WlzCMesh2D5 *mesh,
				  WlzCMeshNod2D5 *nod);
static void			WlzCMeshRemNodFromGrid3D(
				  WlzCMesh3D *mesh,
				  WlzCMeshNod3D *nod);
static void			WlzCMeshEntMarkFree(
				  int *idx);
static void			WlzCMeshRemElmFromGrid2D(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D *elm);
static void			WlzCMeshRemElmFromGrid2D5(
				  WlzCMesh2D5 *mesh,
				  WlzCMeshElm2D5 *elm);
static void 			WlzCMeshRemEntCb(
				  WlzCMeshCbEntry **list,
				  WlzCMeshCbFn fn,
				  void *data);
static void			WlzCMeshNodAddEdu3D(
				  WlzCMeshNod3D *nod,
				  WlzCMeshEdgU3D *edu);
static double			WlzCMeshAddTolToBndAndClamp(
				  double b,
				  double c,
				  double t);
static WlzCMeshCellElm2D 	*WlzCMeshNewCElm2D(
				  WlzCMesh2D *mesh,
				  WlzErrorNum *dstErr);
static WlzCMeshCellElm2D5 	*WlzCMeshNewCElm2D5(
				  WlzCMesh2D5 *mesh,
				  WlzErrorNum *dstErr);
static WlzCMeshCellElm3D 	*WlzCMeshNewCElm3D(
				  WlzCMesh3D *mesh,
				  WlzErrorNum *dstErr);
static WlzErrorNum 		WlzCMeshAllocGridCells2D(
				  WlzCMesh2D *mesh);
static WlzErrorNum 		WlzCMeshAllocGridCells2D5(
				  WlzCMesh2D5 *mesh);
static WlzErrorNum 		WlzCMeshAllocGridCells3D(
				  WlzCMesh3D *mesh);
static WlzErrorNum 		WlzCMeshAddElmToGrid2D(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D *elm);
static WlzErrorNum 		WlzCMeshAddElmToGrid2D5(
				  WlzCMesh2D5 *mesh,
				  WlzCMeshElm2D5 *elm);
static WlzErrorNum 		WlzCMeshAddElmToGrid3D(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D *elm);
static WlzErrorNum 		WlzCMeshElmFuse2D2(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D *gElm,
				  int edgMsk);
static WlzErrorNum 		WlzCMeshElmFuse2D3(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D *gElm);
static int			WlzCMeshCompLBTNodPos2D(
				  WlzDVertex2 *nPos,
				  WlzLBTDomain2D *lDom,
				  int idN,
				  WlzLBTNodeClass2D cls,
				  int rot);
static int			WlzCMeshCompLBTFceNodPos3D(
				  WlzDVertex3 *nPos,
				  WlzLBTDomain3D *lDom,
				  int idN,
				  int idF,
				  WlzLBTNodeClass2D cls,
				  int rot);
static int			WlzCMeshElmWalkPos2D(
				  WlzCMesh2D *mesh,
				  int elmIdx,
				  WlzDVertex2 gPos);
static int			WlzCMeshElmWalkPos3D(
				  WlzCMesh3D *mesh,
				  int elmIdx,
				  WlzDVertex3 gPos);
static int			WlzCMeshElmJumpPos2D(
				  WlzCMesh2D *mesh,
				  WlzDVertex2 gPos,
				  int *dstCloseNod);
static int			WlzCMeshElmJumpPos2D5(
				  WlzCMesh2D5 *mesh,
				  WlzDVertex3 pos,
				  int *dstCloseNod);
static int			WlzCMeshElmJumpPos3D(
				  WlzCMesh3D *mesh,
				  WlzDVertex3 gPos,
				  int *dstCloseNod);
static int			WlzCMeshElmExhaustivePos2D(
				  WlzCMesh2D *mesh,
				  WlzDVertex2 gPos,
				  int *dstCloseNod);
static int			WlzCMeshElmExhaustivePos2D5(
				  WlzCMesh2D5 *mesh,
				  WlzDVertex3 gPos,
				  int *dstCloseNod);
static int			WlzCMeshElmExhaustivePos3D(
				  WlzCMesh3D *mesh,
				  WlzDVertex3 gPos,
				  int *dstCloseNod);
static double	 		WlzCMeshCompGridBSz2D(
				  int nN,
				  double nPB,
				  WlzDVertex2 mSz);
static double	 		WlzCMeshCompGridBSz2D5(
				  int nN,
				  double nPB,
				  WlzDVertex3 mSz);
static double	 		WlzCMeshCompGridBSz3D(
				  int nN,
				  double nPB,
				  WlzDVertex3 mSz);
static WlzErrorNum 		WlzCMeshAddLBTNode2D(
				  WlzCMesh2D *mesh,
				  WlzLBTDomain2D *lDom,
				  WlzGreyValueWSpace *iGVWSp,
				  int idN);
static WlzErrorNum 		WlzCMeshAddLBTNode3D(
				  WlzCMesh3D *mesh,
				  WlzLBTDomain3D *lDom,
				  WlzGreyValueWSpace *iGVWSp,
				  int idN);
static WlzErrorNum 		WlzCMeshAddEntCb(
				  WlzCMeshCbEntry **list,
				  WlzCMeshCbFn fn,
				  void *data);
static WlzErrorNum 		WlzCMeshCallCallbacks(
				  void *meshP,
				  void *entP,
				  WlzCMeshCbEntry *entry);
static WlzErrorNum 		WlzCMeshElmFromLBTNode2D(
				  WlzCMesh2D *mesh,
				  WlzDVertex2 *nPos,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzLBTNodeClass2D cls,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmFromLBTNode3D(
				  WlzCMesh3D *mesh,
				  WlzDVertex3 *nPos,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzLBTNodeClass2D cls);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D0(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D1(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D2(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D3(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D4(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode2D5(
				  WlzCMesh2D *mesh,
				  WlzCMeshElm2D **mElm,
				  WlzCMeshNod2D **mNod,
				  WlzDVertex2 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D0(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D1(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D2(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D3(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D4(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzErrorNum 		WlzCMeshElmsFromLBTNode3D5(
				  WlzCMesh3D *mesh,
				  WlzCMeshElm3D **mElm,
				  WlzCMeshNod3D **mNod,
				  WlzDVertex3 *nPos,
				  int *dstNElm);
static WlzIVertex2 		WlzCMeshCellIdxVtx2D(
				  WlzCMesh2D *mesh,
				  WlzDVertex2 vtx);
static WlzIVertex3 		WlzCMeshCellIdxVtx2D5(
				  WlzCMesh2D5 *mesh,
				  WlzDVertex3 vtx);
static WlzIVertex3 		WlzCMeshCellIdxVtx3D(
				  WlzCMesh3D *mesh,
				  WlzDVertex3 vtx);
static WlzCMeshEdgU2D 		*WlzCMeshEdgUseFindOpp2D(
				  WlzCMeshEdgU2D *gEdu);
static WlzCMeshEdgU2D5 		*WlzCMeshEdgUseFindOpp2D5(
				  WlzCMeshEdgU2D5 *gEdu);
static WlzCMeshFace 		*WlzCMeshFindOppFce(
				  WlzCMeshFace *gFce);

/*!
* \return	New 2D mesh.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh data structure with the resources
*		optimized for the given number of mesh elements and nodes.
*		It is better to under estimate the number of elements and
*		nodes rather than over estimate and if zero is given some
*		reasonable defaults will be used.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMesh2D	*WlzCMeshNew2D(WlzErrorNum *dstErr)
{
  WlzCMesh2D	*mesh = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	nodBSz = 1024,
  		elmBSz = 1024;

  if(errNum == WLZ_ERR_NONE)
  {
    if((mesh = (WlzCMesh2D *)AlcCalloc(1, sizeof(WlzCMesh2D))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->type = WLZ_CMESH_2D;
    if(((mesh->res.nod.vec = AlcVectorNew(1, sizeof(WlzCMeshNod2D),
    					  nodBSz, NULL)) == NULL) ||
       ((mesh->res.elm.vec = AlcVectorNew(1, sizeof(WlzCMeshElm2D),
       					  elmBSz, NULL)) == NULL))
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum != WLZ_ERR_NONE)
  {
    (void )WlzCMeshFree2D(mesh);
    mesh = NULL;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	New 2D5 mesh.
* \ingroup	WlzMesh
* \brief	Creates a new 2D5 mesh data structure with the resources
*		optimized for the given number of mesh elements and nodes.
*		It is better to under estimate the number of elements and
*		nodes rather than over estimate and if zero is given some
*		reasonable defaults will be used.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMesh2D5	*WlzCMeshNew2D5(WlzErrorNum *dstErr)
{
  WlzCMesh2D5	*mesh = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	nodBSz = 1024,
  		elmBSz = 1024;

  if(errNum == WLZ_ERR_NONE)
  {
    if((mesh = (WlzCMesh2D5 *)AlcCalloc(1, sizeof(WlzCMesh2D5))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->type = WLZ_CMESH_2D5;
    if(((mesh->res.nod.vec = AlcVectorNew(1, sizeof(WlzCMeshNod2D5),
    					  nodBSz, NULL)) == NULL) ||
       ((mesh->res.elm.vec = AlcVectorNew(1, sizeof(WlzCMeshElm2D5),
       					  elmBSz, NULL)) == NULL))
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum != WLZ_ERR_NONE)
  {
    (void )WlzCMeshFree2D5(mesh);
    mesh = NULL;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	New 3D mesh.
* \ingroup	WlzMesh
* \brief	Creates a new 3D mesh data structure with the resources
*		optimized for the given number of mesh elements and nodes.
*		It is better to under estimate the number of elements and
*		nodes rather than over estimate and if zero is given some
*		reasonable defaults will be used.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMesh3D	*WlzCMeshNew3D(WlzErrorNum *dstErr)
{
  WlzCMesh3D	*mesh = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	nodBSz = 1024,
  		elmBSz = 1024;

  if(errNum == WLZ_ERR_NONE)
  {
    if((mesh = (WlzCMesh3D *)AlcCalloc(1, sizeof(WlzCMesh3D))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->type = WLZ_CMESH_3D;
    if(((mesh->res.nod.vec = AlcVectorNew(1, sizeof(WlzCMeshNod3D),
    					  nodBSz, NULL)) == NULL) ||
       ((mesh->res.elm.vec = AlcVectorNew(1, sizeof(WlzCMeshElm3D),
       					  elmBSz, NULL)) == NULL))
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum != WLZ_ERR_NONE)
  {
    (void )WlzCMeshFree3D(mesh);
    mesh = NULL;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 2D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 2D5 node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewNodCb2D5(WlzCMesh2D5 *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 3D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewNodCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 2D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 2D5 element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewElmCb2D5(WlzCMesh2D5 *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 3D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddNewElmCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \brief	Adds a 2D deleted node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \brief	Adds a 2D5 deleted node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelNodCb2D5(WlzCMesh2D5 *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \brief	Adds a 3D deleted node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelNodCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a 2D deleted element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a 2D5 deleted element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelElmCb2D5(WlzCMesh2D5 *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a 3D deleted element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshAddDelElmCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  errNum = WlzCMeshAddEntCb(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new 2D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new 2D5 node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewNodCb2D5(WlzCMesh2D5 *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new 3D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewNodCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.nod.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new 2D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new 2D5 element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewElmCb2D5(WlzCMesh2D5 *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a new 3D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemNewElmCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.elm.newEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted 2D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelNodCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted 2D5 node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelNodCb2D5(WlzCMesh2D5 *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted 3D node callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelNodCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.nod.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted 2D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelElmCb2D(WlzCMesh2D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted 2D5 element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelElmCb2D5(WlzCMesh2D5 *mesh, WlzCMeshCbFn fn,
				       void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes a deleted 3D element callback to the mesh.
* \param	mesh			Given mesh.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
WlzErrorNum	WlzCMeshRemDelElmCb3D(WlzCMesh3D *mesh, WlzCMeshCbFn fn,
				      void *data)
{
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  WlzCMeshRemEntCb(&(mesh->res.elm.delEntCb), fn, data);
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds an entity callback to the given 2D mesh callback list.
* \param	list			Given callback list.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
static WlzErrorNum WlzCMeshAddEntCb(WlzCMeshCbEntry **list, WlzCMeshCbFn fn,
				    void *data)
{
  WlzCMeshCbEntry *newCbE = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(list && fn)
  {
    if((newCbE = (WlzCMeshCbEntry *)
    		 AlcMalloc(sizeof(WlzCMeshCbEntry))) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
    else
    {
      newCbE->fn = fn;
      newCbE->data = data;
      newCbE->next = *list;
      *list = newCbE;
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Removes an entity callback from the given 2D mesh callback
*		list.
* \param	list			Given callback list.
* \param	fn			Function to be called.
* \param	data			Callback data for function.
*/
static void 	WlzCMeshRemEntCb(WlzCMeshCbEntry **list, WlzCMeshCbFn fn,
				 void *data)
{
  WlzCMeshCbEntry *cBE0,
  		*cBE1;

  if(list && ((cBE1 = *list) != NULL) && fn)
  {
    cBE0 = NULL;
    while((fn != cBE1->fn) && (data != cBE1->data) && cBE1->next)
    {
      cBE0 = cBE1;
      cBE1 = cBE1->next;
    }
    if((fn == cBE1->fn) && (data == cBE1->data))
    {
      if(cBE0)
      {
        cBE0->next = cBE1->next;
      }
      else
      {
        *list = NULL;
      }
      AlcFree(cBE1);
    }
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Calls all calbacks in the given list.
* \param	meshP			The mesh.
* \param	entP			The entity (node or element).
* \param	entry			Callback entry.
*/
static WlzErrorNum WlzCMeshCallCallbacks(void *meshP, void *entP,
				      WlzCMeshCbEntry *entry)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  while(entry && (errNum == WLZ_ERR_NONE))
  {
    if(entry->fn)
    {
      errNum = (*(entry->fn))(meshP, entP, entry->data);
    }
    entry = entry->next;
  }
  return(errNum);
}

/*!
* \return	New 2D mesh node.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh node at the given position. It is
*		assumed that a node does not already exist at the given
*		position but for efficiency this is not checked.
* \param	mesh			The mesh for resources.
* \param	pos			Position for the node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshNod2D	*WlzCMeshNewNod2D(WlzCMesh2D *mesh, WlzDVertex2 pos,
				  WlzErrorNum *dstErr)
{
  WlzCMeshNod2D	*nNod = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;


  if((nNod = WlzCMeshAllocNod2D(mesh)) == NULL)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  else
  {
    nNod->pos = pos;
    nNod->next = NULL;
    WlzCMeshAddNodToGrid2D(mesh, nNod);
  }
  if((errNum == WLZ_ERR_NONE) && mesh->res.nod.newEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nNod, mesh->res.nod.newEntCb);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nNod);
}

/*!
* \return	New 2D5 mesh node.
* \ingroup	WlzMesh
* \brief	Creates a new 2D5 mesh node at the given position. It is
*		assumed that a node does not already exist at the given
*		position but for efficiency this is not checked.
* \param	mesh			The mesh for resources.
* \param	pos			Position for the node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshNod2D5	*WlzCMeshNewNod2D5(WlzCMesh2D5 *mesh, WlzDVertex3 pos,
				  WlzErrorNum *dstErr)
{
  WlzCMeshNod2D5 *nNod = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;


  if((nNod = WlzCMeshAllocNod2D5(mesh)) == NULL)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  else
  {
    nNod->pos = pos;
    nNod->next = NULL;
    WlzCMeshAddNodToGrid2D5(mesh, nNod);
  }
  if((errNum == WLZ_ERR_NONE) && mesh->res.nod.newEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nNod, mesh->res.nod.newEntCb);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nNod);
}

/*!
* \return	New 3D mesh node.
* \ingroup	WlzMesh
* \brief	Creates a new 3D mesh node at the given position. A node
*		must not already exist at this position.
* \param	mesh			The mesh for resources.
* \param	pos			Position for the node.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshNod3D	*WlzCMeshNewNod3D(WlzCMesh3D *mesh, WlzDVertex3 pos,
				  WlzErrorNum *dstErr)
{
  WlzCMeshNod3D	*nNod = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;


  if((nNod = WlzCMeshAllocNod3D(mesh)) == NULL)
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  else
  {
    nNod->pos = pos;
    nNod->flags = 0;
    WlzCMeshAddNodToGrid3D(mesh, nNod);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nNod);
}

/*!
* \ingroup	WlzMesh
* \brief	Adds a new mesh node to the mesh's cell grid.
*		It is assumed that the given node is not already in the
*		cell grid but this is not checked for.
* \param	mesh			The mesh.
* \param	nod			Node to add to the cell grid.
*/
static void	WlzCMeshAddNodToGrid2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  WlzIVertex2	idx;
  WlzCMeshCell2D *cell;

  /* Find the cell in the grid. */
  idx = WlzCMeshCellIdxVtx2D(mesh, nod->pos);
  cell = *(mesh->cGrid.cells + idx.vtY) + idx.vtX;
  /* Add the node to the cell. */
  nod->next = cell->nod; cell->nod = nod;
}

/*!
* \ingroup	WlzMesh
* \brief	Adds a new mesh node to the mesh's cell grid.
*		It is assumed that the given node is not already in the
*		cell grid but this is not checked for.
* \param	mesh			The mesh.
* \param	nod			Node to add to the cell grid.
*/
static void	WlzCMeshAddNodToGrid2D5(WlzCMesh2D5 *mesh, WlzCMeshNod2D5 *nod)
{
  WlzIVertex3	idx;
  WlzCMeshCell2D5 *cell;

  /* Find the cell in the grid. */
  idx = WlzCMeshCellIdxVtx2D5(mesh, nod->pos);
  cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
  /* Add the node to the cell. */
  nod->next = cell->nod; cell->nod = nod;
}

/*!
* \ingroup	WlzMesh
* \brief	Adds a new mesh node to the mesh's cell grid.
*		It is assumed that the given node is not already in the
*		cell grid but this is not checked for.
* \param	mesh			The mesh.
* \param	nod			Node to add to the cell grid.
*/
static void	WlzCMeshAddNodToGrid3D(WlzCMesh3D *mesh, WlzCMeshNod3D *nod)
{
  WlzIVertex3	idx;
  WlzCMeshCell3D *cell;

  /* Find the cell in the grid. */
  idx = WlzCMeshCellIdxVtx3D(mesh, nod->pos);
  cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
  /* Add the node to the cell. */
  nod->next = cell->nod; cell->nod = nod;
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 2D mesh element to the mesh's cell grid.
* 		It is assumed that the given element is not already in the
* 		cell grid but this is not checked for.
* \param	mesh			The mesh.
* \param	elm			Element to add to the cell grid.
*/
static WlzErrorNum WlzCMeshAddElmToGrid2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm)
{
  double	delta;
  WlzIVertex2	idx;
  WlzDVertex2	cBoxMin,
  		cBoxMax;
  WlzIBox2	cBox;
  WlzDBox2	eBox;
  WlzCMeshCell2D *cell;
  WlzCMeshCellElm2D *cElm;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const double	eps = 0.001;

  elm->cElm = NULL;
  delta = eps * mesh->cGrid.cellSz;
  /* Find grid cells that may be intersected by the element on the basis
   * of this element's axis aligned bounding box. */
  eBox = WlzCMeshElmBBox2D(elm);
  cBox.xMin = (int )floor((eBox.xMin - mesh->bBox.xMin - delta) /
                          mesh->cGrid.cellSz);
  cBox.yMin = (int )floor((eBox.yMin - mesh->bBox.yMin - delta) /
                          mesh->cGrid.cellSz);
  cBox.xMax = (int )ceil((eBox.xMax - mesh->bBox.xMin + delta) /
                         mesh->cGrid.cellSz);
  cBox.yMax = (int )ceil((eBox.yMax - mesh->bBox.yMin + delta) /
                         mesh->cGrid.cellSz);
  cBox.xMin = WLZ_CLAMP(cBox.xMin, 0,  mesh->cGrid.nCells.vtX - 1);
  cBox.xMax = WLZ_CLAMP(cBox.xMax, 0,  mesh->cGrid.nCells.vtX - 1);
  cBox.yMin = WLZ_CLAMP(cBox.yMin, 0,  mesh->cGrid.nCells.vtY - 1);
  cBox.yMax = WLZ_CLAMP(cBox.yMax, 0,  mesh->cGrid.nCells.vtY - 1);
  /* For each of the grid cells found, check for an intersection with the
   * element and then if there is an intersection add a grid cell element
   * to the cell. */
  for(idx.vtY = cBox.yMin; idx.vtY <= cBox.yMax; ++idx.vtY)
  {
    cBoxMin.vtY = mesh->bBox.yMin + (idx.vtY * mesh->cGrid.cellSz);
    cBoxMax.vtY = mesh->bBox.yMin + ((idx.vtY + 1) * mesh->cGrid.cellSz);
    for(idx.vtX = cBox.xMin; idx.vtX <= cBox.xMax; ++idx.vtX)
    {
      cBoxMin.vtX = mesh->bBox.xMin + (idx.vtX * mesh->cGrid.cellSz);
      cBoxMax.vtX = mesh->bBox.xMin + ((idx.vtX + 1) * mesh->cGrid.cellSz);
      /* Faster to test using AABB(cell)/AABB(element) only and incur
       * false positives. */
      if(WlzGeomTriangleAABBIntersect2D(elm->edu[0].nod->pos,
					elm->edu[1].nod->pos,
					elm->edu[2].nod->pos,
					cBoxMin, cBoxMax, 1) != 0)
      {
        if((cElm = WlzCMeshNewCElm2D(mesh, &errNum)) == NULL)
	{
	  goto RETURN;
	}
	cElm->elm = elm;
	cell = *(mesh->cGrid.cells + idx.vtY) + idx.vtX;
	cElm->cell = cell;
	/* Next element of this cell. */
	cElm->next = cell->cElm; cell->cElm = cElm;
	/* Next cell of this element. */
	cElm->nextCell = elm->cElm; elm->cElm = cElm;
      }
    }
  }
RETURN:
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 2D5 mesh element to the mesh's cell grid.
* 		It is assumed that the given element is not already in the
* 		cell grid but this is not checked for.
* \param	mesh			The mesh.
* \param	elm			Element to add to the cell grid.
*/
static WlzErrorNum WlzCMeshAddElmToGrid2D5(WlzCMesh2D5 *mesh,
					   WlzCMeshElm2D5 *elm)
{
  double	delta;
  WlzIVertex3	idx;
  WlzDVertex3	cBoxMin,
  		cBoxMax;
  WlzIBox3	cBox;
  WlzDBox3	eBox;
  WlzCMeshCell2D5 *cell;
  WlzCMeshCellElm2D5 *cElm;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const double	eps = 0.001;

  elm->cElm = NULL;
  delta = eps * mesh->cGrid.cellSz;
  /* Find grid cells that may be intersected by the element on the basis
   * of this element's axis aligned bounding box. */
  eBox = WlzCMeshElmBBox2D5(elm);
  cBox.xMin = (int )floor((eBox.xMin - mesh->bBox.xMin - delta) /
                          mesh->cGrid.cellSz);
  cBox.yMin = (int )floor((eBox.yMin - mesh->bBox.yMin - delta) /
                          mesh->cGrid.cellSz);
  cBox.zMin = (int )floor((eBox.zMin - mesh->bBox.zMin - delta) /
                          mesh->cGrid.cellSz);
  cBox.xMax = (int )ceil((eBox.xMax - mesh->bBox.xMin + delta) /
                         mesh->cGrid.cellSz);
  cBox.yMax = (int )ceil((eBox.yMax - mesh->bBox.yMin + delta) /
                         mesh->cGrid.cellSz);
  cBox.zMax = (int )ceil((eBox.zMax - mesh->bBox.zMin + delta) /
                         mesh->cGrid.cellSz);
  cBox.xMin = WLZ_CLAMP(cBox.xMin, 0,  mesh->cGrid.nCells.vtX - 1);
  cBox.xMax = WLZ_CLAMP(cBox.xMax, 0,  mesh->cGrid.nCells.vtX - 1);
  cBox.yMin = WLZ_CLAMP(cBox.yMin, 0,  mesh->cGrid.nCells.vtY - 1);
  cBox.yMax = WLZ_CLAMP(cBox.yMax, 0,  mesh->cGrid.nCells.vtY - 1);
  cBox.zMin = WLZ_CLAMP(cBox.zMin, 0,  mesh->cGrid.nCells.vtZ - 1);
  cBox.zMax = WLZ_CLAMP(cBox.zMax, 0,  mesh->cGrid.nCells.vtZ - 1);
  /* For each of the grid cells found, check for an intersection with the
   * element and then if there is an intersection add a grid cell element
   * to the cell. */
  for(idx.vtZ = cBox.zMin; idx.vtZ <= cBox.zMax; ++idx.vtZ)
  {
    cBoxMin.vtZ = mesh->bBox.zMin + (idx.vtZ * mesh->cGrid.cellSz);
    cBoxMax.vtZ = mesh->bBox.zMin + ((idx.vtZ + 1) * mesh->cGrid.cellSz);
    for(idx.vtY = cBox.yMin; idx.vtY <= cBox.yMax; ++idx.vtY)
    {
      cBoxMin.vtY = mesh->bBox.yMin + (idx.vtY * mesh->cGrid.cellSz);
      cBoxMax.vtY = mesh->bBox.yMin + ((idx.vtY + 1) * mesh->cGrid.cellSz);
      for(idx.vtX = cBox.xMin; idx.vtX <= cBox.xMax; ++idx.vtX)
      {
	cBoxMin.vtX = mesh->bBox.xMin + (idx.vtX * mesh->cGrid.cellSz);
	cBoxMax.vtX = mesh->bBox.xMin + ((idx.vtX + 1) * mesh->cGrid.cellSz);
	/* Faster to test using AABB(cell)/AABB(element) only and incur
	 * false positives. */
	if(WlzGeomTriangleAABBIntersect3D(elm->edu[0].nod->pos,
					  elm->edu[1].nod->pos,
					  elm->edu[2].nod->pos,
					  cBoxMin, cBoxMax, 1) != 0)
	{
	  if((cElm = WlzCMeshNewCElm2D5(mesh, &errNum)) == NULL)
	  {
	    goto RETURN;
	  }
	  cElm->elm = elm;
	  cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
	  cElm->cell = cell;
	  /* Next element of this cell. */
	  cElm->next = cell->cElm; cell->cElm = cElm;
	  /* Next cell of this element. */
	  cElm->nextCell = elm->cElm; elm->cElm = cElm;
	}
      }
    }
  }
RETURN:
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Adds a new 3D mesh element to the mesh's cell grid.
* 		It is assumed that the given element is not already in the
* 		cell grid but this is not checked for.
* \param	mesh			The mesh.
* \param	elm			Element to add to the cell grid.
*/
static WlzErrorNum WlzCMeshAddElmToGrid3D(WlzCMesh3D *mesh, WlzCMeshElm3D *elm)
{
  double	delta;
  WlzIVertex3	idx;
  WlzDVertex3	cBoxMin,
  		cBoxMax;
  WlzIBox3	cBox;
  WlzDBox3	eBox;
  WlzCMeshCell3D *cell;
  WlzCMeshCellElm3D *cElm;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const double	eps = 0.001;

  elm->cElm = NULL;
  delta = eps * mesh->cGrid.cellSz;
  /* Find grid cells that may be intersected by the element on the basis
   * of this element's axis aligned bounding box. */
  eBox = WlzCMeshElmBBox3D(elm);
  cBox.xMin = (int )floor((eBox.xMin - mesh->bBox.xMin - delta) /
                          mesh->cGrid.cellSz);
  cBox.yMin = (int )floor((eBox.yMin - mesh->bBox.yMin - delta) /
                          mesh->cGrid.cellSz);
  cBox.zMin = (int )floor((eBox.zMin - mesh->bBox.zMin - delta) /
                          mesh->cGrid.cellSz);
  cBox.xMax = (int )ceil((eBox.xMax - mesh->bBox.xMin + delta) /
                         mesh->cGrid.cellSz);
  cBox.yMax = (int )ceil((eBox.yMax - mesh->bBox.yMin + delta) /
                         mesh->cGrid.cellSz);
  cBox.zMax = (int )ceil((eBox.zMax - mesh->bBox.zMin + delta) /
                         mesh->cGrid.cellSz);
  cBox.xMin = WLZ_CLAMP(cBox.xMin, 0,  mesh->cGrid.nCells.vtX - 1);
  cBox.xMax = WLZ_CLAMP(cBox.xMax, 0,  mesh->cGrid.nCells.vtX - 1);
  cBox.yMin = WLZ_CLAMP(cBox.yMin, 0,  mesh->cGrid.nCells.vtY - 1);
  cBox.yMax = WLZ_CLAMP(cBox.yMax, 0,  mesh->cGrid.nCells.vtY - 1);
  cBox.zMin = WLZ_CLAMP(cBox.zMin, 0,  mesh->cGrid.nCells.vtZ - 1);
  cBox.zMax = WLZ_CLAMP(cBox.zMax, 0,  mesh->cGrid.nCells.vtZ - 1);
  /* For each of the grid cells found, check for an intersection with the
   * element and then if there is an intersection add a grid cell element
   * to the cell. */
  for(idx.vtZ = cBox.zMin; idx.vtZ <= cBox.zMax; ++idx.vtZ)
  {
    cBoxMin.vtZ = mesh->bBox.zMin + (idx.vtZ * mesh->cGrid.cellSz);
    cBoxMax.vtZ = mesh->bBox.zMin + ((idx.vtZ + 1) * mesh->cGrid.cellSz);
    for(idx.vtY = cBox.yMin; idx.vtY <= cBox.yMax; ++idx.vtY)
    {
      cBoxMin.vtY = mesh->bBox.yMin + (idx.vtY * mesh->cGrid.cellSz);
      cBoxMax.vtY = mesh->bBox.yMin + ((idx.vtY + 1) * mesh->cGrid.cellSz);
      for(idx.vtX = cBox.xMin; idx.vtX <= cBox.xMax; ++idx.vtX)
      {
	cBoxMin.vtX = mesh->bBox.xMin + (idx.vtX * mesh->cGrid.cellSz);
	cBoxMax.vtX = mesh->bBox.xMin + ((idx.vtX + 1) * mesh->cGrid.cellSz);
	/* Faster to test using AABB(cell)/AABB(element) only and incur
	 * false positives. */
	if(WlzGeomTetrahedronAABBIntersect3D(elm->face[0].edu[0].nod->pos,
					     elm->face[0].edu[1].nod->pos,
					     elm->face[0].edu[2].nod->pos,
					     elm->face[1].edu[1].nod->pos,
					     cBoxMin, cBoxMax, 1) != 0)
	{
	  if((cElm = WlzCMeshNewCElm3D(mesh, &errNum)) == NULL)
	  {
	    goto RETURN;
	  }
	  cElm->elm = elm;
	  cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
	  cElm->cell = cell;
	  /* Next element of this cell. */
	  cElm->next = cell->cElm; cell->cElm = cElm;
	  /* Next cell of this element. */
	  cElm->nextCell = elm->cElm; elm->cElm = cElm;
	}
      }
    }
  }
RETURN:
  return(errNum);
}

/*!
* \return	New mesh cell element.
* \ingroup	WlzMesh
* \brief	Gets a new 2D mesh cell element allocating more cell
* 		elements as required.
* \param	mesh			The mesh.
* \param	dstErr			Destination error pointer, may be NULL.
*/
static WlzCMeshCellElm2D *WlzCMeshNewCElm2D(WlzCMesh2D *mesh,
				            WlzErrorNum *dstErr)
{
  int		idE;
  WlzCMeshCellElm2D *cElm = NULL;
  WlzCMeshCellGrid2D *cGrid;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int 	elmBSz = 1024;

  cGrid = &(mesh->cGrid);
  if(cGrid->freeCE == NULL)
  {
    cGrid->allCE = AlcBlockStackNew(elmBSz, sizeof(WlzCMeshCellElm2D),
				    cGrid->allCE, NULL);
    
    if(cGrid->allCE == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
    else
    {
      cElm = (WlzCMeshCellElm2D *)(cGrid->allCE->elements);
      for(idE = 0; idE < elmBSz; ++idE)
      {
	cElm->next = cGrid->freeCE;
	cGrid->freeCE = cElm;
	++cElm;
      }
    }
  }
  if(cGrid->freeCE != NULL)
  {
    cElm = cGrid->freeCE;
    cGrid->freeCE = cElm->next;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(cElm);
}

/*!
* \return	New mesh cell element.
* \ingroup	WlzMesh
* \brief	Gets a new 2D5 mesh cell element allocating more cell
* 		elements as required.
* \param	mesh			The mesh.
* \param	dstErr			Destination error pointer, may be NULL.
*/
static WlzCMeshCellElm2D5 *WlzCMeshNewCElm2D5(WlzCMesh2D5 *mesh,
				            WlzErrorNum *dstErr)
{
  int		idE;
  WlzCMeshCellElm2D5 *cElm = NULL;
  WlzCMeshCellGrid2D5 *cGrid;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int 	elmBSz = 1024;

  cGrid = &(mesh->cGrid);
  if(cGrid->freeCE == NULL)
  {
    cGrid->allCE = AlcBlockStackNew(elmBSz, sizeof(WlzCMeshCellElm2D5),
				    cGrid->allCE, NULL);
    
    if(cGrid->allCE == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
    else
    {
      cElm = (WlzCMeshCellElm2D5 *)(cGrid->allCE->elements);
      for(idE = 0; idE < elmBSz; ++idE)
      {
	cElm->next = cGrid->freeCE;
	cGrid->freeCE = cElm;
	++cElm;
      }
    }
  }
  if(cGrid->freeCE != NULL)
  {
    cElm = cGrid->freeCE;
    cGrid->freeCE = cElm->next;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(cElm);
}

/*!
* \return	New mesh cell element.
* \ingroup	WlzMesh
* \brief	Gets a new 3D mesh cell element allocating more cell
* 		elements as required.
* \param	mesh			The mesh.
* \param	dstErr			Destination error pointer, may be NULL.
*/
static WlzCMeshCellElm3D *WlzCMeshNewCElm3D(WlzCMesh3D *mesh,
				            WlzErrorNum *dstErr)
{
  int		idE;
  WlzCMeshCellElm3D *cElm = NULL;
  WlzCMeshCellGrid3D *cGrid;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int 	elmBSz = 1024;

  cGrid = &(mesh->cGrid);
  if(cGrid->freeCE == NULL)
  {
    cGrid->allCE = AlcBlockStackNew(elmBSz, sizeof(WlzCMeshCellElm3D),
				    cGrid->allCE, NULL);
    
    if(cGrid->allCE == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
    else
    {
      cElm = (WlzCMeshCellElm3D *)(cGrid->allCE->elements);
      for(idE = 0; idE < elmBSz; ++idE)
      {
	cElm->next = cGrid->freeCE;
	cGrid->freeCE = cElm;
	++cElm;
      }
    }
  }
  if(cGrid->freeCE != NULL)
  {
    cElm = cGrid->freeCE;
    cGrid->freeCE = cElm->next;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(cElm);
}

/*!
* \ingroup	WlzMesh
* \brief	Removes a mesh node from the mesh's cell grid.
* \param	mesh			The mesh.
* \param	nod			New node to add.
*/
static void	WlzCMeshRemNodFromGrid2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  WlzCMeshNod2D	*nod0,
  		*nod1;
  WlzIVertex2	idx;
  WlzCMeshCell2D *cell;

  /* Find the cell in the grid. */
  idx = WlzCMeshCellIdxVtx2D(mesh, nod->pos);
  cell = *(mesh->cGrid.cells + idx.vtY) + idx.vtX;
  /* Remove node from linked list of nodes in the cell. */
  if(cell->nod != NULL)
  {
    if(cell->nod == nod)
    {
      cell->nod = nod->next;
    }
    else
    {
      nod0 = cell->nod;
      while((nod1 = nod0->next) != NULL)
      {
	if(nod1 == nod)
	{
	  nod0->next = nod1->next;
	  break;
	}
	nod0 = nod1;
      }
    }
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Removes a mesh node from the mesh's cell grid.
* \param	mesh			The mesh.
* \param	nod			New node to add.
*/
static void	WlzCMeshRemNodFromGrid2D5(WlzCMesh2D5 *mesh,
                                          WlzCMeshNod2D5 *nod)
{
  WlzCMeshNod2D5 *nod0,
  		*nod1;
  WlzIVertex3	idx;
  WlzCMeshCell2D5 *cell;

  /* Find the cell in the grid. */
  idx = WlzCMeshCellIdxVtx2D5(mesh, nod->pos);
  cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
  /* Remove node from linked list of nodes in the cell. */
  if(cell->nod != NULL)
  {
    if(cell->nod == nod)
    {
      cell->nod = nod->next;
    }
    else
    {
      nod0 = cell->nod;
      while((nod1 = nod0->next) != NULL)
      {
	if(nod1 == nod)
	{
	  nod0->next = nod1->next;
	  break;
	}
	nod0 = nod1;
      }
    }
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Removes a mesh node from the mesh's cell grid.
* \param	mesh			The mesh.
* \param	nod			New node to add.
*/
static void	WlzCMeshRemNodFromGrid3D(WlzCMesh3D *mesh, WlzCMeshNod3D *nod)
{
  WlzCMeshNod3D	*nod0,
  		*nod1;
  WlzIVertex3	idx;
  WlzCMeshCell3D *cell;

  /* Find the cell in the grid. */
  idx = WlzCMeshCellIdxVtx3D(mesh, nod->pos);
  cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
  /* Remove node from linked list of nodes in the cell. */
  if(cell->nod != NULL)
  {
    if(cell->nod == nod)
    {
      cell->nod = nod->next;
    }
    else
    {
      nod0 = cell->nod;
      while((nod1 = nod0->next) != NULL)
      {
	if(nod1 == nod)
	{
	  nod0->next = nod1->next;
	  break;
	}
	nod0 = nod1;
      }
    }
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Removes a 2D mesh element from the cell linked list.
* \param	mesh			The mesh.
* \param	elm			Elememnt to remove.
*/
static void	WlzCMeshRemElmFromGrid2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm)
{
  WlzCMeshCellElm2D *cElm0,
  		*cElm1,
		*cElm2;
  WlzCMeshCell2D *cell;

  cElm0 = elm->cElm;
  while(cElm0 != NULL)
  {
    cell = cElm0->cell;
    cElm1 = NULL;
    cElm2 = cell->cElm;
    while(cElm2 != NULL)
    {
      if(cElm2->elm == elm)
      {
	if(cElm1 == NULL)
	{
	  cell->cElm = cElm2->next;
	}
	else
	{
	  cElm1->next = cElm2->next;
	}
	cElm2->next = mesh->cGrid.freeCE; mesh->cGrid.freeCE = cElm2;
        break;
      }
      cElm1 = cElm2;
      cElm2 = cElm2->next;           /* Next element intersecting this cell. */
    }
    cElm0 = cElm0->nextCell;            /* Next cell intersected by element. */
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Removes a 2D5 mesh element from the cell linked list.
* \param	mesh			The mesh.
* \param	elm			Elememnt to remove.
*/
static void	WlzCMeshRemElmFromGrid2D5(WlzCMesh2D5 *mesh,
					  WlzCMeshElm2D5 *elm)
{
  WlzCMeshCellElm2D5 *cElm0,
  		*cElm1,
		*cElm2;
  WlzCMeshCell2D5 *cell;

  cElm0 = elm->cElm;
  while(cElm0 != NULL)
  {
    cell = cElm0->cell;
    cElm1 = NULL;
    cElm2 = cell->cElm;
    while(cElm2 != NULL)
    {
      if(cElm2->elm == elm)
      {
	if(cElm1 == NULL)
	{
	  cell->cElm = cElm2->next;
	}
	else
	{
	  cElm1->next = cElm2->next;
	}
	cElm2->next = mesh->cGrid.freeCE; mesh->cGrid.freeCE = cElm2;
        break;
      }
      cElm1 = cElm2;
      cElm2 = cElm2->next;           /* Next element intersecting this cell. */
    }
    cElm0 = cElm0->nextCell;            /* Next cell intersected by element. */
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Removes a 3D mesh element from the cell linked list.
* \param	mesh			The mesh.
* \param	elm			Elememnt to remove.
*/
static void	WlzCMeshRemElmFromGrid3D(WlzCMesh3D *mesh, WlzCMeshElm3D *elm)
{
  WlzCMeshCellElm3D *cElm0,
  		*cElm1,
		*cElm2;
  WlzCMeshCell3D *cell;

  cElm0 = elm->cElm;
  while(cElm0 != NULL)
  {
    cell = cElm0->cell;
    cElm1 = NULL;
    cElm2 = cell->cElm;
    while(cElm2 != NULL)
    {
      if(cElm2->elm == elm)
      {
	if(cElm1 == NULL)
	{
	  cell->cElm = cElm2->next;
	}
	else
	{
	  cElm1->next = cElm2->next;
	}
	cElm2->next = mesh->cGrid.freeCE; mesh->cGrid.freeCE = cElm2;
        break;
      }
      cElm1 = cElm2;
      cElm2 = cElm2->next;           /* Next element intersecting this cell. */
    }
    cElm0 = cElm0->nextCell;            /* Next cell intersected by element. */
  }
}

/*!
* \return	New 2D mesh node or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D mesh node and sets it's index. 
*		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
*/
WlzCMeshNod2D 	*WlzCMeshAllocNod2D(WlzCMesh2D *mesh)
{
  WlzCMeshEntRes *nRes;
  WlzCMeshNod2D	*nod = NULL;
  
  nRes = &(mesh->res.nod);
  if((nod = (WlzCMeshNod2D *)
	    (AlcVectorExtendAndGet(nRes->vec, nRes->nextIdx))) != NULL)
  {
    ++(nRes->numEnt);
    ++(nRes->maxEnt);
    nod->idx = nRes->nextIdx++;
  }
  return(nod);
}

/*!
* \return	New 2D5 mesh node or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D5 mesh node and sets it's index. 
*		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
*/
WlzCMeshNod2D5 	*WlzCMeshAllocNod2D5(WlzCMesh2D5 *mesh)
{
  WlzCMeshEntRes *nRes;
  WlzCMeshNod2D5 *nod = NULL;
  
  nRes = &(mesh->res.nod);
  if((nod = (WlzCMeshNod2D5 *)
	    (AlcVectorExtendAndGet(nRes->vec, nRes->nextIdx))) != NULL)
  {
    ++(nRes->numEnt);
    ++(nRes->maxEnt);
    nod->idx = nRes->nextIdx++;
  }
  return(nod);
}

/*!
* \return	New 3D mesh node or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 3D mesh node and sets it's index. 
*		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
*/
WlzCMeshNod3D 	*WlzCMeshAllocNod3D(WlzCMesh3D *mesh)
{
  WlzCMeshEntRes	*nRes;
  WlzCMeshNod3D	*nod = NULL;
  
  nRes = &(mesh->res.nod);
  if((nod = (WlzCMeshNod3D *)
	    (AlcVectorExtendAndGet(nRes->vec, nRes->nextIdx))) != NULL)
  {
    ++(nRes->numEnt);
    ++(nRes->maxEnt);
    nod->idx = nRes->nextIdx++;
  }
  return(nod);
}

/*!
* \return	New 2D mesh element.
* \ingroup	WlzMesh
* \brief	Creates a new 2D mesh element connecting the given
*		mesh nodes but does not connect this new mesh element
*		to the rest of the mesh apart from changing the parent
*		edges of the mesh nodes.
* \param	mesh			The mesh for resources.
* \param	nod0			First mesh node.
* \param	nod1			Second mesh node.
* \param	nod2			Third mesh node.
* \param	allowFlip		Allow flipping of node order to get
* 					valid element.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshElm2D 	*WlzCMeshNewElm2D(WlzCMesh2D *mesh,
				  WlzCMeshNod2D *nod0, WlzCMeshNod2D *nod1,
				  WlzCMeshNod2D *nod2, int allowFlip,
				  WlzErrorNum *dstErr)
{
  WlzCMeshElm2D	*nElm = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((nod0 == NULL) || (nod1 == NULL) || (nod2 == NULL))
  {
    errNum = WLZ_ERR_PARAM_NULL;
  }
  else
  {
    if((nElm = WlzCMeshAllocElm2D(mesh)) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshSetElm2D(mesh, nElm, nod0, nod1, nod2, allowFlip);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshAddElmToGrid2D(mesh, nElm);
  }
  if((errNum == WLZ_ERR_NONE) && mesh->res.elm.newEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nElm, mesh->res.elm.newEntCb);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nElm);
}

/*!
* \return	New 2D5 mesh element.
* \ingroup	WlzMesh
* \brief	Creates a new 2D5 mesh element connecting the given
*		mesh nodes but does not connect this new mesh element
*		to the rest of the mesh apart from changing the parent
*		edges of the mesh nodes.
* \param	mesh			The mesh for resources.
* \param	nod0			First mesh node.
* \param	nod1			Second mesh node.
* \param	nod2			Third mesh node.
* \param	allowFlip		Allow flipping of node order to get
* 					valid element.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshElm2D5 	*WlzCMeshNewElm2D5(WlzCMesh2D5 *mesh,
				   WlzCMeshNod2D5 *nod0, WlzCMeshNod2D5 *nod1,
				   WlzCMeshNod2D5 *nod2, int allowFlip,
				   WlzErrorNum *dstErr)
{
  WlzCMeshElm2D5 *nElm = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((nod0 == NULL) || (nod1 == NULL) || (nod2 == NULL))
  {
    errNum = WLZ_ERR_PARAM_NULL;
  }
  else
  {
    if((nElm = WlzCMeshAllocElm2D5(mesh)) == NULL) 
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshSetElm2D5(mesh, nElm, nod0, nod1, nod2, allowFlip);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshAddElmToGrid2D5(mesh, nElm);
  }
  if((errNum == WLZ_ERR_NONE) && mesh->res.elm.newEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nElm, mesh->res.elm.newEntCb);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nElm);
}

/*!
* \return	New 3D mesh element.
* \ingroup	WlzMesh
* \brief	Creates a new 3D mesh element connecting the given
*		mesh nodes but does not connect this new mesh element
*		to the rest of the mesh apart from changing the parent
*		edges of the mesh nodes.
* 		Each mesh element is composed of 4 faces and 4 nodes,
*		with each of the 4 faces having 3 edges. See the diagrams
*		accompanying the definition of WlzCMeshElm3D.
* \param	mesh			The mesh for resources.
* \param	nod0			First mesh node.
* \param	nod1			Second mesh node.
* \param	nod2			Third mesh node.
* \param	nod3			Fourth mesh node.
* \param	allowFlip		Allow flipping of node order to get
* 					valid element.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzCMeshElm3D 	*WlzCMeshNewElm3D(WlzCMesh3D *mesh,
				  WlzCMeshNod3D *nod0, WlzCMeshNod3D *nod1,
				  WlzCMeshNod3D *nod2, WlzCMeshNod3D *nod3,
				  int allowFlip, WlzErrorNum *dstErr)
{
  WlzCMeshElm3D	*nElm = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((nod0 == NULL) || (nod1 == NULL) || (nod2 == NULL) || (nod3 == NULL))
  {
    errNum = WLZ_ERR_PARAM_NULL;
  }
  else
  {
    if((nElm = WlzCMeshAllocElm3D(mesh)) == NULL)
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshSetElm3D(mesh, nElm, nod0, nod1, nod2, nod3, allowFlip);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshAddElmToGrid3D(mesh, nElm);
  }
  if((errNum == WLZ_ERR_NONE) && mesh->res.elm.newEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nElm, mesh->res.elm.newEntCb);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(nElm);
}

/*!
* \return	New 2D mesh element or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D mesh element and sets it's index. 
*		Internal edge connectivities are set.
* 		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
*/
WlzCMeshElm2D 	*WlzCMeshAllocElm2D(WlzCMesh2D *mesh)
{
  WlzCMeshEntRes	*eRes;
  WlzCMeshElm2D	*elm = NULL;
  
  eRes = &(mesh->res.elm);
  if((elm = (WlzCMeshElm2D *)
	    (AlcVectorExtendAndGet(eRes->vec, eRes->nextIdx))) != NULL)
  {
    ++(eRes->numEnt);
    ++(eRes->maxEnt);
    elm->idx = eRes->nextIdx++;
    elm->edu[0].next = &(elm->edu[1]);
    elm->edu[1].next = &(elm->edu[2]);
    elm->edu[2].next = &(elm->edu[0]);
  }
  return(elm);
}

/*!
* \return	New 2D5 mesh element or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 2D5 mesh element and sets it's index. 
*		Internal edge connectivities are set.
* 		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
*/
WlzCMeshElm2D5 	*WlzCMeshAllocElm2D5(WlzCMesh2D5 *mesh)
{
  WlzCMeshEntRes *eRes;
  WlzCMeshElm2D5 *elm = NULL;
  
  eRes = &(mesh->res.elm);
  if((elm = (WlzCMeshElm2D5 *)
	    (AlcVectorExtendAndGet(eRes->vec, eRes->nextIdx))) != NULL)
  {
    ++(eRes->numEnt);
    ++(eRes->maxEnt);
    elm->idx = eRes->nextIdx++;
    elm->edu[0].next = &(elm->edu[1]);
    elm->edu[1].next = &(elm->edu[2]);
    elm->edu[2].next = &(elm->edu[0]);
  }
  return(elm);
}

/*!
* \return	New 3D mesh element or NULL on error.
* \ingroup	WlzMesh
* \brief	Allocates a new 3D mesh element and sets it's index. 
* 		For efficiency this function does not check it's parameters.
* \param	mesh			Mesh with resources.
*/
WlzCMeshElm3D 	*WlzCMeshAllocElm3D(WlzCMesh3D *mesh)
{
  WlzCMeshEntRes	*eRes;
  WlzCMeshElm3D	*elm = NULL;
  
  eRes = &(mesh->res.elm);
  if((elm = (WlzCMeshElm3D *)
	    (AlcVectorExtendAndGet(eRes->vec, eRes->nextIdx))) != NULL)
  {
    ++(eRes->numEnt);
    ++(eRes->maxEnt);
    elm->idx = eRes->nextIdx++;
  }
  return(elm);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets up the edge and node connectivities within the given
*		2D mesh element.
*		The geometry of the element is checked to make sure that
*		it's area is greater than the mesh tolerance and that
*		the nodes are in CCW order. If this test fails an error
*		is returned.
* \param	mesh			The mesh.
* \param	elm			Given mesh element.
* \param	nod0			First mesh node of element.
* \param	nod1			Second mesh node of element.
* \param	nod2			Third mesh node of element.
* \param	allowFlip		Allow flipping of node order to get
* 					valid element.
*/
WlzErrorNum  	WlzCMeshSetElm2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm,
				     WlzCMeshNod2D *nod0, WlzCMeshNod2D *nod1,
				     WlzCMeshNod2D *nod2, int allowFlip)
{
  int		idE,
  		idN;
  double	lenSq,
  		sA2;
  WlzCMeshEdgU2D *edu;
  WlzDVertex2	dsp;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  sA2 = WlzGeomTriangleSnArea2(nod0->pos, nod1->pos, nod2->pos);
  if(sA2 < WLZ_MESH_TOLERANCE_SQ)
  {
    if((allowFlip == 0) || (sA2 > -WLZ_MESH_TOLERANCE_SQ))
    {
      /* Element either has a very small area or is CW. */
      errNum = WLZ_ERR_PARAM_DATA;
    }
    else
    {
      WlzCMeshNod2D *tNod;

      tNod = nod1; nod1 = nod2; nod2 = tNod;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    elm->edu[0].nod = nod0;
    elm->edu[1].nod = nod1;
    elm->edu[2].nod = nod2;
    /* Set internal adjacencies and check for maximum edge length. */
    for(idE = 0; idE < 3; ++idE)
    {
      idN = (idE + 1) % 3;
      edu = &(elm->edu[idE]);
      edu->elm = elm;
      edu->next = &(elm->edu[idN]);
      if(edu->nod->edu)
      {
        edu->nnxt = edu->nod->edu->nnxt;
	edu->nod->edu->nnxt = edu;
      }
      else
      {
        edu->nnxt = edu;
	edu->nod->edu = edu;
      }
      WLZ_VTX_2_SUB(dsp, elm->edu[idE].nod->pos, elm->edu[idN].nod->pos);
      lenSq = WLZ_VTX_2_SQRLEN(dsp);
      if(lenSq > mesh->maxSqEdgLen)
      {
        mesh->maxSqEdgLen = lenSq;
      }
    }
    /* Set external adjacencies. */
    for(idE = 0; idE < 3; ++idE)
    {
      edu = &(elm->edu[idE]);
      if((edu->opp = WlzCMeshEdgUseFindOpp2D(edu)) != NULL)
      {
        edu->opp->opp = edu;
      }
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets up the edge and node connectivities within the given
*		2D5 mesh element.
*		The geometry of the element is checked to make sure that
*		it's area is greater than the mesh tolerance and that
*		the nodes are in CCW order. If this test fails an error
*		is returned.
* \param	mesh			The mesh.
* \param	elm			Given mesh element.
* \param	nod0			First mesh node of element.
* \param	nod1			Second mesh node of element.
* \param	nod2			Third mesh node of element.
* \param	allowFlip		Allow flipping of node order to get
* 					valid element.
*/
WlzErrorNum  	WlzCMeshSetElm2D5(WlzCMesh2D5 *mesh, WlzCMeshElm2D5 *elm,
				 WlzCMeshNod2D5 *nod0, WlzCMeshNod2D5 *nod1,
				 WlzCMeshNod2D5 *nod2, int allowFlip)
{
  int		idE,
  		idN;
  double	lenSq,
  		sA2;
  WlzCMeshEdgU2D5 *edu;
  WlzDVertex3	dsp;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  sA2 = WlzGeomTriangleArea2Sq3(nod0->pos, nod1->pos, nod2->pos);
  if(sA2 < WLZ_MESH_TOLERANCE_SQ)
  {
    if((allowFlip == 0) || (sA2 > -WLZ_MESH_TOLERANCE_SQ))
    {
      /* Element either has a very small area or is CW. */
      errNum = WLZ_ERR_PARAM_DATA;
    }
    else
    {
      WlzCMeshNod2D5 *tNod;

      tNod = nod1; nod1 = nod2; nod2 = tNod;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    elm->edu[0].nod = nod0;
    elm->edu[1].nod = nod1;
    elm->edu[2].nod = nod2;
    /* Set internal adjacencies and check for maximum edge length. */
    for(idE = 0; idE < 3; ++idE)
    {
      idN = (idE + 1) % 3;
      edu = &(elm->edu[idE]);
      edu->elm = elm;
      edu->next = &(elm->edu[idN]);
      if(edu->nod->edu)
      {
        edu->nnxt = edu->nod->edu->nnxt;
	edu->nod->edu->nnxt = edu;
      }
      else
      {
        edu->nnxt = edu;
	edu->nod->edu = edu;
      }
      WLZ_VTX_3_SUB(dsp, elm->edu[idE].nod->pos, elm->edu[idN].nod->pos);
      lenSq = WLZ_VTX_3_SQRLEN(dsp);
      if(lenSq > mesh->maxSqEdgLen)
      {
        mesh->maxSqEdgLen = lenSq;
      }
    }
    /* Set external adjacencies. */
    for(idE = 0; idE < 3; ++idE)
    {
      edu = &(elm->edu[idE]);
      if((edu->opp = WlzCMeshEdgUseFindOpp2D5(edu)) != NULL)
      {
        edu->opp->opp = edu;
      }
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Sets up the edge and node connectivities within the given
*		3D mesh element. No opposites are changed.
*		The geometry of the element is checked to make sure that
*		it's volume is greater than the mesh tolerance, ie that
*		the nodes are correclty ordered and are not co planar.
*		If this test fails an error is returned.
* \param	mesh			The mesh.
* \param	elm			Given mesh element.
* \param	nod0			First mesh node of element.
* \param	nod1			Second mesh node of element.
* \param	nod2			Third mesh node of element.
* \param	nod3			Fourth mesh node of element.
* \param	allowFlip		Allow flipping of node order to get
* 					valid element.
*/
WlzErrorNum  	WlzCMeshSetElm3D(WlzCMesh3D *mesh, WlzCMeshElm3D *elm,
				     WlzCMeshNod3D *nod0, WlzCMeshNod3D *nod1,
				     WlzCMeshNod3D *nod2, WlzCMeshNod3D *nod3,
				     int allowFlip)
{
  int		idE,
  		idF,
		idN;
  double	lenSq,
  		sV6;
  WlzDVertex3	pos0,
  		pos1,
		dsp;
  WlzCMeshNod3D	*nod[4];
  WlzCMeshFace	*fce;
  WlzCMeshEdgU3D *edu;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  /* See the diagrams with the definition of WlzCMeshElm3D for the node,
   * edge and face numbering. */
  const int	edgNodTbl[4][3] = /* [fce, edu] -> node index within the
                                     element. */
		{
  		  {0, 1, 2},
  		  {0, 3, 1},
  		  {0, 2, 3},
  		  {2, 1, 3}
		};
  const int	nodTbl0[6] = {0, 0, 0, 1, 1, 2},
           	nodTbl1[6] = {1, 2, 3, 2, 3, 3};

  sV6 = WlzGeomTetraSnVolume6(nod0->pos, nod1->pos, nod2->pos, nod3->pos);
  if(sV6 < WLZ_MESH_TOLERANCE_SQ)
  {
    if((allowFlip == 0) || (sV6 > -WLZ_MESH_TOLERANCE_SQ))
    {
      /* Element either has a very small area or is CW. */
      errNum = WLZ_ERR_PARAM_DATA;
    }
    else
    {
      WlzCMeshNod3D *tNod;

      tNod = nod2; nod2 = nod3; nod3 = tNod;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    nod[0] = nod0;
    nod[1] = nod1;
    nod[2] = nod2;
    nod[3] = nod3;
    /* Set up all the adjacencies. */
    for(idF = 0; idF < 4; ++idF)
    {
      fce = elm->face + idF;
      for(idE = 0; idE < 3; ++idE)
      {
        idN = (idE + 1) % 3;
        edu = fce->edu + idE;
	edu->nod = nod[edgNodTbl[idF][idE]];
	if(edu->nod->edu == NULL)
	{
	  edu->nod->edu = edu;
	}
	edu->next = fce->edu + idN;
	WlzCMeshNodAddEdu3D(edu->nod, edu); /* Sets edu->nnxt */
	edu->face = fce;
      }
      fce->opp = NULL;
      fce->elm = elm;
    }
    for(idF = 0; idF < 4; ++idF)
    {
      fce = elm->face + idF;
      if((fce->opp = WlzCMeshFindOppFce(fce)) != NULL)
      {
        fce->opp->opp = fce;
      }
    }
    /* Check for maximum edge length. */
    for(idE = 0; idE < 6; ++idE)
    {
      pos0 = nod[nodTbl0[idE]]->pos;
      pos1 = nod[nodTbl1[idE]]->pos;
      WLZ_VTX_3_SUB(dsp, pos0, pos1);
      lenSq = WLZ_VTX_3_SQRLEN(dsp);
      if(lenSq > mesh->maxSqEdgLen)
      {
        mesh->maxSqEdgLen = lenSq;
      }
    }
  }
  return(errNum);
}

/*!
* \return	Opposite face or NULL.
* \ingroup	WlzMesh
* \brief	Finds the face opposite to the given face within the mesh.
* 		This function is only needed when building a mesh. To speed
* 		up checking for the opposite face, the sum of the face node
* 		indices is used to quickly reject most possible faces.
* \param	gFce			Given face.
*/
static WlzCMeshFace *WlzCMeshFindOppFce(WlzCMeshFace *gFce)
{
  int		idM,
  		idN,
		gIdxSum,
		tIdxSum,
		cnt = 0;
  WlzCMeshNod3D	*tmp;
  WlzCMeshEdgU3D *fEdg,
  		*tEdg;
  WlzCMeshFace	*tFce,
  		*oFce = NULL;
  WlzCMeshNod3D *gNod[3],
  		*tNod[3];

  gNod[0] = gFce->edu[0].nod;
  gNod[1] = gFce->edu[1].nod;
  gNod[2] = gFce->edu[2].nod;
  tEdg = fEdg = gNod[0]->edu;
  gIdxSum = gNod[0]->idx + gNod[1]->idx + gNod[2]->idx;
  do
  {
    cnt = 0;
    tFce = tEdg->face;
    if(tFce != gFce)
    {
      tNod[0] = tFce->edu[0].nod;
      tNod[1] = tFce->edu[1].nod;
      tNod[2] = tFce->edu[2].nod;
      tIdxSum = tNod[0]->idx + tNod[1]->idx + tNod[2]->idx;
      if(tIdxSum == gIdxSum)
      {
	/* Sum of node indices around face is the same, yet it's not the
	 * same face. It's probably the opposite face, but may not be so
	 * check for nodes being the same. */
	for(idN = 0; idN < 3; ++idN)
	{
	  for(idM = idN; idM < 3; ++idM)
	  {
	    if(tNod[idM] == gNod[idN])
	    {
	      if(idN < 2)
	      {
		tmp = tNod[idN];
		tNod[idN] = tNod[idM];
		tNod[idM] = tmp;
	      }
	      ++cnt;
	      break;
	    }
	  }
	  if(cnt != (idN + 1))
	  {
	    break;
	  }
	}
      }
    }
    if(cnt == 3)
    {
      oFce = tFce;
      break;
    }
    tEdg = tEdg->nnxt;
  } while (tEdg != fEdg);
  return(oFce);
}

/*!
* \ingroup	WlzMesh
* \brief	Adds an edge use to the circular linked list of edges
* 		directed from the node. The node and edge use must both
* 		be valid and the use must not be in the list already.
* \param	nod			The node.
* \param	edu			The edge directed from the node.
*/
static void	WlzCMeshNodAddEdu3D(WlzCMeshNod3D *nod, WlzCMeshEdgU3D *edu)
{
  if(nod->edu == NULL)
  {
    nod->edu = edu->nnxt = edu;
  }
  else
  {
    edu->nnxt = nod->edu->nnxt;
    nod->edu->nnxt = edu;
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's the mesh, it's cells, nodes and elements.
* \param	mesh			Mesh to free.
*/
WlzErrorNum	WlzCMeshFree(WlzCMeshP mesh)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh.v == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    switch(mesh.m2->type)
    {
      case WLZ_CMESH_2D:
        errNum = WlzCMeshFree2D(mesh.m2);
	break;
      case WLZ_CMESH_2D5:
        errNum = WlzCMeshFree2D5(mesh.m2d5);
	break;
      case WLZ_CMESH_3D:
        errNum = WlzCMeshFree3D(mesh.m3);
	break;
      default:
        errNum = WLZ_ERR_DOMAIN_TYPE;
	break;
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's the 2D mesh, it's cells, nodes and elements.
* \param	mesh			Mesh to free.
*/
WlzErrorNum	WlzCMeshFree2D(WlzCMesh2D *mesh)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzUnlink(&(mesh->linkcount), &errNum))
  {
    (void )AlcVectorFree(mesh->res.elm.vec);
    (void )AlcVectorFree(mesh->res.nod.vec);
    (void )AlcBlockStackFree(mesh->cGrid.allCE);
    (void )WlzCMeshFreeGridCells2D(mesh);
    AlcFree(mesh);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's the 2D5 mesh, it's cells, nodes and elements.
* \param	mesh			Mesh to free.
*/
WlzErrorNum	WlzCMeshFree2D5(WlzCMesh2D5 *mesh)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzUnlink(&(mesh->linkcount), &errNum))
  {
    (void )AlcVectorFree(mesh->res.elm.vec);
    (void )AlcVectorFree(mesh->res.nod.vec);
    (void )AlcBlockStackFree(mesh->cGrid.allCE);
    (void )WlzCMeshFreeGridCells2D5(mesh);
    AlcFree(mesh);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Free's the 3D mesh, it's cells, nodes and elements.
* \param	mesh			Mesh to free.
*/
WlzErrorNum	WlzCMeshFree3D(WlzCMesh3D *mesh)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzUnlink(&(mesh->linkcount), &errNum))
  {
    (void )AlcVectorFree(mesh->res.elm.vec);
    (void )AlcVectorFree(mesh->res.nod.vec);
    (void )AlcBlockStackFree(mesh->cGrid.allCE);
    (void )WlzCMeshFreeGridCells3D(mesh);
    AlcFree(mesh);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 2D mesh node. This function assumes that the node
*		is no longer used by any elements.
* \param	mesh			The mesh to which the node belongs.
* \param	nod			The given node.
*/
WlzErrorNum	WlzCMeshDelNod2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (nod == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((errNum == WLZ_ERR_NONE) && mesh->res.nod.delEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nod, mesh->res.nod.delEntCb);
  }
  else
  {
    WlzCMeshRemNodFromGrid2D(mesh, nod);
    WlzCMeshNodFree2D(mesh, nod);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 2D5 mesh node. This function assumes that the node
*		is no longer used by any elements.
* \param	mesh			The mesh to which the node belongs.
* \param	nod			The given node.
*/
WlzErrorNum	WlzCMeshDelNod2D5(WlzCMesh2D5 *mesh, WlzCMeshNod2D5 *nod)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (nod == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((errNum == WLZ_ERR_NONE) && mesh->res.nod.delEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nod, mesh->res.nod.delEntCb);
  }
  else
  {
    WlzCMeshRemNodFromGrid2D5(mesh, nod);
    WlzCMeshNodFree2D5(mesh, nod);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 3D mesh node. This function assumes that the node
*		is no longer used by any elements.
* \param	mesh			The mesh to which the node belongs.
* \param	nod			The given node.
*/
WlzErrorNum	WlzCMeshDelNod3D(WlzCMesh3D *mesh, WlzCMeshNod3D *nod)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (nod == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((errNum == WLZ_ERR_NONE) && mesh->res.nod.delEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, nod, mesh->res.nod.delEntCb);
  }
  else
  {
    WlzCMeshRemNodFromGrid3D(mesh, nod);
    WlzCMeshNodFree3D(mesh, nod);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 2D mesh element and any mesh nodes that are
*		used exclusively by this mesh element. 
* \param	mesh			The mesh to which the element belongs.
* \param	elm			The given element.
*/
WlzErrorNum	WlzCMeshDelElm2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm)
{
  int		idE;
  WlzCMeshEdgU2D *edu0,
  		*edu1,
		*edu2;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

#ifdef WLZ_CMESH_DEBUG_VERIFY_DELETE
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
  }
#endif
  if((mesh == NULL) || (elm == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((errNum == WLZ_ERR_NONE) && mesh->res.elm.delEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, elm, mesh->res.elm.delEntCb);
  }
  else
  {
    for(idE = 0; idE < 3; ++idE)
    {
      edu0 = elm->edu + idE;
      /* Need to make sure that the opp - opp link is back to this
       * element and not some other that will replace it. */
      if((edu0->opp != NULL) && (edu0->opp->opp != NULL) &&
         (edu0->opp->opp->elm == elm))
      {
        edu0->opp->opp = NULL;
      }
      if(edu0 == edu0->nnxt)
      {
        (void )WlzCMeshDelNod2D(mesh, edu0->nod);
      }
      else
      {
        edu1 = edu0;
	while((edu2 = edu1->nnxt) != edu0)
	{
	  edu1 = edu2;
	}
	edu1->nnxt = edu0->nnxt;
	if(edu0->nod->edu == edu0)
	{
	  edu0->nod->edu = edu1;
	}
      }
    }
    if(errNum == WLZ_ERR_NONE)
    {
      WlzCMeshRemElmFromGrid2D(mesh, elm);
      WlzCMeshElmFree2D(mesh, elm);
    }
  }
#ifdef WLZ_CMESH_DEBUG_VERIFY_DELETE
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 2D5 mesh element and any mesh nodes that are
*		used exclusively by this mesh element. 
* \param	mesh			The mesh to which the element belongs.
* \param	elm			The given element.
*/
WlzErrorNum	WlzCMeshDelElm2D5(WlzCMesh2D5 *mesh, WlzCMeshElm2D5 *elm)
{
  int		idE;
  WlzCMeshEdgU2D5 *edu0,
  		*edu1,
		*edu2;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

#ifdef WLZ_CMESH_DEBUG_VERIFY_DELETE
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D5(mesh, NULL, 1, stderr);
  }
#endif
  if((mesh == NULL) || (elm == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((errNum == WLZ_ERR_NONE) && mesh->res.elm.delEntCb)
  {
    errNum = WlzCMeshCallCallbacks(mesh, elm, mesh->res.elm.delEntCb);
  }
  else
  {
    for(idE = 0; idE < 3; ++idE)
    {
      edu0 = elm->edu + idE;
      /* Need to make sure that the opp - opp link is back to this
       * element and not some other that will replace it. */
      if((edu0->opp != NULL) && (edu0->opp->opp != NULL) &&
         (edu0->opp->opp->elm == elm))
      {
        edu0->opp->opp = NULL;
      }
      if(edu0 == edu0->nnxt)
      {
        (void )WlzCMeshDelNod2D5(mesh, edu0->nod);
      }
      else
      {
        edu1 = edu0;
	while((edu2 = edu1->nnxt) != edu0)
	{
	  edu1 = edu2;
	}
	edu1->nnxt = edu0->nnxt;
	if(edu0->nod->edu == edu0)
	{
	  edu0->nod->edu = edu1;
	}
      }
    }
    if(errNum == WLZ_ERR_NONE)
    {
      WlzCMeshRemElmFromGrid2D5(mesh, elm);
      WlzCMeshElmFree2D5(mesh, elm);
    }
  }
#ifdef WLZ_CMESH_DEBUG_VERIFY_DELETE
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D5(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Deletes the 3D mesh element and any mesh nodes that are
*		used exclusively by this mesh element. 
* \param	mesh			The mesh to which the element belongs.
* \param	elm			The given element.
*/
WlzErrorNum	WlzCMeshDelElm3D(WlzCMesh3D *mesh, WlzCMeshElm3D *elm)
{
  int		idE,
  		idF;
  WlzCMeshEdgU3D *edu0,
  		*edu1,
		*edu2;
  WlzCMeshFace	*fce0;
  WlzErrorNum errNum = WLZ_ERR_NONE;

  for(idF = 0; idF < 4; ++idF)
  {
    fce0 = elm->face + idF;
    /* Unlink edge uses from the nodes. */
    for(idE = 0; idE < 3; ++idE)
    {
      edu0 = fce0->edu + idE;
      if(edu0 == edu0->nnxt)
      {
	/* Node is only used by this edge so it can be deleted. */
        (void )WlzCMeshDelNod3D(mesh, edu0->nod);
      }
      else
      {
        edu1 = edu0;
	edu2 = edu1->nnxt;
	while(edu2 != edu0)
	{
	  edu1 = edu2;
	  edu2 = edu2->nnxt;
	}
	edu1->nnxt = edu2->nnxt;
	edu1->nod->edu = edu1;
      }
    }
    /* Unlink face. Need to make sure that the opp - opp link is back to
     * this element and not some other that will replace it. */
    if((fce0->opp != NULL) && (fce0->opp->opp != NULL) &&
       (fce0->opp->opp->elm == elm))
    {
      fce0->opp->opp = NULL;
    }
  }
  WlzCMeshRemElmFromGrid3D(mesh, elm);
  WlzCMeshElmFree3D(mesh, elm);
#ifdef WLZ_CMESH_DEBUG_VERIFY_DELETE
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify3D(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return	<void>
* \ingroup	WlzMesh
* \brief	Sets the index to indicate that the mesh entity is free.
* \param	idx			Entity index pointer.
*/
static void	WlzCMeshEntMarkFree(int *idx)
{
  if(*idx >= 0)
  {
    *idx = -(*idx + 1);
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Free's the given 2D mesh node. Actually just sets the
*		node's index to mark it freed and then decrements
*		the number of mesh nodes.
* \param	mesh			Input mesh
* \param	nod			Given mesh node.
*/
void 		WlzCMeshNodFree2D(WlzCMesh2D *mesh, WlzCMeshNod2D *nod)
{
  if(nod && (nod->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(nod->idx));
    --(mesh->res.nod.numEnt);
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Free's the given 2D5 mesh node. Actually just sets the
*		node's index to mark it freed and then decrements
*		the number of mesh nodes.
* \param	mesh			Input mesh
* \param	nod			Given mesh node.
*/
void 		WlzCMeshNodFree2D5(WlzCMesh2D5 *mesh, WlzCMeshNod2D5 *nod)
{
  if(nod && (nod->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(nod->idx));
    --(mesh->res.nod.numEnt);
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Free's the given 3D mesh node. Actually just sets the
*		node's index to mark it freed and then decrements
*		the number of mesh nodes.
* \param	mesh			Input mesh
* \param	nod			Given mesh node.
*/
void 		WlzCMeshNodFree3D(WlzCMesh3D *mesh, WlzCMeshNod3D *nod)
{
  if(nod && (nod->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(nod->idx));
    --(mesh->res.nod.numEnt);
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Free's the given 2D mesh element. Actually just sets the
*		element's index to mark it freed and then decrements
*		the number of mesh elements.
* \param	mesh			Input mesh
* \param	elm			Given mesh element.
*/
void		WlzCMeshElmFree2D(WlzCMesh2D *mesh, WlzCMeshElm2D *elm)
{
  if(elm && (elm->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(elm->idx));
    --(mesh->res.elm.numEnt);
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Free's the given 2D5 mesh element. Actually just sets the
*		element's index to mark it freed and then decrements
*		the number of mesh elements.
* \param	mesh			Input mesh
* \param	elm			Given mesh element.
*/
void		WlzCMeshElmFree2D5(WlzCMesh2D5 *mesh, WlzCMeshElm2D5 *elm)
{
  if(elm && (elm->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(elm->idx));
    --(mesh->res.elm.numEnt);
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Free's the given 3D mesh element. Actually just sets the
*		element's index to mark it freed and then decrements
*		the number of mesh elements.
* \param	mesh			Input mesh
* \param	elm			Given mesh element.
*/
void		WlzCMeshElmFree3D(WlzCMesh3D *mesh, WlzCMeshElm3D *elm)
{
  if(elm && (elm->idx >= 0))
  {
    WlzCMeshEntMarkFree(&(elm->idx));
    --(mesh->res.elm.numEnt);
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Deletes any unused neodes, ie nodes that do not have edge
* 		uses, from the given mesh.
* \param	mesh			Given mesh.
*/
void 		WlzCMeshDelUnusedNodes3D(WlzCMesh3D *mesh)
{
  if((mesh == NULL) || (mesh->type == WLZ_CMESH_3D))
  {
    int		idN;
    WlzCMeshNod3D *nod;

    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod3D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->edu == NULL)
      {
        (void )WlzCMeshDelNod3D(mesh, nod);
      }
    }
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Deletes any unused neodes, ie nodes that do not have edge
* 		uses, from the given mesh.
* \param	mesh			Given mesh.
*/
void 		WlzCMeshDelUnusedNodes2D5(WlzCMesh2D5 *mesh)
{
  if((mesh == NULL) || (mesh->type == WLZ_CMESH_2D5))
  {
    int		idN;
    WlzCMeshNod2D5 *nod;

    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D5 *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->edu == NULL)
      {
        (void )WlzCMeshDelNod2D5(mesh, nod);
      }
    }
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Deletes any unused neodes, ie nodes that do not have edge
* 		uses, from the given mesh.
* \param	mesh			Given mesh.
*/
void 		WlzCMeshDelUnusedNodes2D(WlzCMesh2D *mesh)
{
  if((mesh == NULL) || (mesh->type == WLZ_CMESH_2D))
  {
    int		idN;
    WlzCMeshNod2D *nod;

    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->edu == NULL)
      {
        (void )WlzCMeshDelNod2D(mesh, nod);
      }
    }
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Affine transforms the node positions of the given 2D mesh.
* \param	mesh			Given mesh.
* \param	tr			Affine transform.
*/
WlzErrorNum	WlzCMeshAffineTransformMesh2D(WlzCMesh2D *mesh,
					      WlzAffineTransform *tr)
{
  int		idN,
  		nNod;
  WlzCMeshNod2D	*nod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (tr == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzAffineTransformDimension(tr, NULL) != 2)
  {
    errNum = WLZ_ERR_TRANSFORM_TYPE;
  }
  else
  {
    /* Transform the nodes. */
    nNod = 0;
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	++nNod;
        nod->pos = WlzAffineTransformVertexD2(tr, nod->pos, NULL);
      }
    }
    /* Update the bounding box. */
    WlzCMeshUpdateBBox2D(mesh);
    /* Compute a new cell grid and reassign nodes to it. */
    errNum = WlzCMeshReassignGridCells2D(mesh, nNod);
    /* Recompute maximum edge length. */
    WlzCMeshUpdateMaxSqEdgLen2D(mesh);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Affine transforms the node positions of the given 2D5 mesh.
* \param	mesh			Given mesh.
* \param	tr			Affine transform.
*/
WlzErrorNum	WlzCMeshAffineTransformMesh2D5(WlzCMesh2D5 *mesh,
					       WlzAffineTransform *tr)
{
  int		idN,
  		nNod;
  WlzCMeshNod2D5 *nod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (tr == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzAffineTransformDimension(tr, NULL) != 3)
  {
    errNum = WLZ_ERR_TRANSFORM_TYPE;
  }
  else
  {
    /* Transform the nodes. */
    nNod = 0;
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D5 *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	++nNod;
        nod->pos = WlzAffineTransformVertexD3(tr, nod->pos, NULL);
      }
    }
    /* Update the bounding box. */
    WlzCMeshUpdateBBox2D5(mesh);
    /* Recompute maximum edge length. */
    WlzCMeshUpdateMaxSqEdgLen2D5(mesh);
    /* Compute a new cell grid and reassign nodes to it. */
    errNum = WlzCMeshReassignGridCells2D5(mesh, nNod);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Affine transforms the node positions of the given 3D mesh.
* \param	mesh			Given mesh.
* \param	tr			Affine transform.
*/
WlzErrorNum	WlzCMeshAffineTransformMesh3D(WlzCMesh3D *mesh,
					      WlzAffineTransform *tr)
{
  int		idN,
  		nNod;
  WlzCMeshNod3D	*nod;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if((mesh == NULL) || (tr == NULL))
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(WlzAffineTransformDimension(tr, NULL) != 3)
  {
    errNum = WLZ_ERR_TRANSFORM_TYPE;
  }
  else
  {
    /* Transform the nodes. */
    nNod = 0;
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod3D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	++nNod;
        nod->pos = WlzAffineTransformVertexD3(tr, nod->pos, NULL);
      }
    }
    /* Update the bounding box. */
    WlzCMeshUpdateBBox3D(mesh);
    /* Recompute maximum edge length. */
    WlzCMeshUpdateMaxSqEdgLen3D(mesh);
    /* Compute a new cell grid and reassign nodes to it. */
    errNum = WlzCMeshReassignGridCells3D(mesh, nNod);
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Examines all the mesh elements classifying the nodes as
* 		either inside or outside the object. Those elements which
* 		have either one or two nodes outside the domain object have
* 		their position modified so that they are just outside.
* 		All elements with all nodes outside the domain object are
* 		deleted.
* 		On return the mesh bounding box and location grid will be
* 		invalid and the following functions should be called:
* 		WlzCMeshUpdateBBox3D(), WlzCMeshUpdateMaxSqEdgLen3D() 
* 		and WlzCMeshReassignGridCells3D().
* \param	mesh			Given mesh.
* \param	obj			Object with domain to which the
*					mesh should conform.
* \param	mtd			Method for determining the position
* 					of a vertex just outside the object's
* 					domain, see
* 					WlzGeomObjLineSegIntersect2D().
* \param	tol			Acceptable placement error.
*/
WlzErrorNum 	WlzCMeshBoundConform2D(WlzCMesh2D *mesh,
					WlzObject *obj,
					int mtd, double tol)
{
  int		idE,
		idN;
  WlzCMeshNod2D *nod;
  WlzCMeshElm2D	*elm;
  WlzCMeshNod2D *nodes[3];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Pass 0: Classify all nodes as either inside or outside the
   * domain of the given object, marking those outside as such. */
  for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
  {
    nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
    if(nod->idx >= 0)
    {
      nod->flags = WlzInsideDomain(obj,
                                   0.0, nod->pos.vtY, nod->pos.vtX,
				   NULL)?
                   WLZ_CMESH_NOD_FLAG_NONE: WLZ_CMESH_NOD_FLAG_OUTSIDE;
    }
  }
  /* Pass 1: Classify all elements of the mesh and in all boundary elements
   * (in which at least one node is inside and at least node one is outside)
   * slide nodes marked as outside along an edge. */
  for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
  {
    elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
    if(elm->idx >= 0)
    {
      unsigned int msk = 0;
      WlzDVertex2 pos;

      nodes[0] = WLZ_CMESH_ELM2D_GET_NODE_0(elm);
      nodes[1] = WLZ_CMESH_ELM2D_GET_NODE_1(elm);
      nodes[2] = WLZ_CMESH_ELM2D_GET_NODE_2(elm);
      for(idN = 0; idN < 3; ++idN)
      {
	if((nodes[idN]->flags & WLZ_CMESH_NOD_FLAG_OUTSIDE) != 0)
	{
          msk |= 1 << idN;
	}
      }
      switch(msk)
      {
        case 0: /*  0|000|0 */
	  elm->flags = WLZ_CMESH_ELM_FLAG_NONE;
	  break;
	case 1: /*  1|001|1 */
	  pos = WlzGeomObjLineSegIntersect2D(obj,
					     nodes[0]->pos, nodes[1]->pos,
					     tol, 0, mtd, NULL);
	  nodes[0]->pos = pos;
	  nodes[0]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 2: /*  2|010|1 */
	  pos = WlzGeomObjLineSegIntersect2D(obj,
	                                     nodes[1]->pos, nodes[0]->pos,
	  				     tol, 0, mtd, NULL);
	  nodes[1]->pos = pos;
	  nodes[1]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 4: /*  4|100|1 */
	  pos = WlzGeomObjLineSegIntersect2D(obj,
	  				     nodes[2]->pos, nodes[0]->pos,
	  				     tol, 0, mtd, NULL);
	  nodes[2]->pos = pos;
	  nodes[2]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 3: /*  3|011|2 */
	  for(idN = 0; idN < 2; ++idN)
	  {
	    pos = WlzGeomObjLineSegIntersect2D(obj,
	                                       nodes[idN]->pos, nodes[2]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 5: /*  5|101|2 */
	  for(idN = 0; idN < 3; idN += 2)
	  {
	    pos = WlzGeomObjLineSegIntersect2D(obj,
	                                       nodes[idN]->pos, nodes[1]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 6: /*  6|110|2 */
	  for(idN = 1; idN < 3; ++idN)
	  {
	    pos = WlzGeomObjLineSegIntersect2D(obj,
	                                       nodes[idN]->pos, nodes[0]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 7: /*  7|111|3 */ /* FALLTHROUGH */
	default:
	  elm->flags = WLZ_CMESH_ELM_FLAG_OUTSIDE;
	  break;
      }
    }
  }
  /* Pass 2: Delete all elements flaged as outside. */
  for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
  {
    elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
    if(elm->idx >= 0)
    {
      if((elm->flags & WLZ_CMESH_ELM_FLAG_OUTSIDE) != 0)
      {
        (void )WlzCMeshDelElm2D(mesh, elm);
      }
    }
  }
  /* Pass 3: Delete all very small elements. */
#ifdef WLZ_CMESH_ELM_FUSE_2D_OK
  for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
  {
    elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
    if(elm->idx >= 0)
    {

      if((elm->flags & WLZ_CMESH_ELM_FLAG_BOUNDARY) != 0)
      {
	double sA2;

	nodes[0] = WLZ_CMESH_ELM2D_GET_NODE_0(elm);
	nodes[1] = WLZ_CMESH_ELM2D_GET_NODE_1(elm);
	nodes[2] = WLZ_CMESH_ELM2D_GET_NODE_2(elm);
	sA2 = WlzGeomTriangleSnArea2(nodes[0]->pos, nodes[1]->pos,
				     nodes[2]->pos);
	if(sA2 < 1.0)
	{
	  errNum = WlzCMeshElmFuse2D(mesh, elm);
	}
      }
    }
  }
#endif
#ifdef WLZ_CMESH_DEBUG_VERIFY_CONFORM
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Examines all the mesh elements deleting those with all
* 		elements outside and decomposing those on it's boundary.
* 		At the first pass boundary elements (those with between one
* 		and three nodes outside the object's domain) are decomposed
* 		into one or three new elements and elements which have all
* 		four nodes outside the domain are deleted. In the second
* 		pass new elements outside the domain are deleted.
*
* 		On return the mesh bounding box and location grid will be
* 		invalid and the following functions should be called:
* 		WlzCMeshUpdateBBox3D(), WlzCMeshUpdateMaxSqEdgLen3D() 
* 		and WlzCMeshReassignGridCells3D().
* \param	mesh			Given mesh.
* \param	obj			Object with domain to which the
*					mesh should conform.
* \param	mtd			Method for determining the position
* 					of a vertex just outside the object's
* 					domain, see
* 					WlzGeomObjLineSegIntersect3D().
* \param	tol			Acceptable placement error.
*/
WlzErrorNum 	WlzCMeshBoundConform3D(WlzCMesh3D *mesh,
					WlzObject *obj,
					int mtd, double tol)
{
  int		idE,
		idN;
  WlzCMeshNod3D *nod;
  WlzCMeshElm3D	*elm;
  WlzCMeshNod3D *nodes[4];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Pass 0: Classify all nodes as either inside or outside the
   * domain of the given object, marking those outside as such. */
  for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
  {
    nod = (WlzCMeshNod3D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
    if(nod->idx >= 0)
    {
      nod->flags = WlzInsideDomain(obj,
                                   nod->pos.vtZ, nod->pos.vtY, nod->pos.vtX,
				   NULL)?
                   WLZ_CMESH_NOD_FLAG_NONE: WLZ_CMESH_NOD_FLAG_OUTSIDE;
    }
  }
  /* Pass 1: Classify all elements of the mesh and in all boundary elements
   * (in which at least one node is inside and at least node one is outside)
   * slide nodes marked as outside along an edge. */
  for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
  {
    elm = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
    if(elm->idx >= 0)
    {
      unsigned int msk = 0;
      WlzDVertex3 pos;

      nodes[0] = WLZ_CMESH_ELM3D_GET_NODE_0(elm);
      nodes[1] = WLZ_CMESH_ELM3D_GET_NODE_1(elm);
      nodes[2] = WLZ_CMESH_ELM3D_GET_NODE_2(elm);
      nodes[3] = WLZ_CMESH_ELM3D_GET_NODE_3(elm);
      for(idN = 0; idN < 4; ++idN)
      {
        if((nodes[idN]->flags & WLZ_CMESH_NOD_FLAG_OUTSIDE) != 0)
	{
	  msk |= 1 << idN;
	}
      }
      switch(msk)
      {
        case 0:  /*  0|0000|0 */
	  elm->flags = WLZ_CMESH_ELM_FLAG_NONE;
	  break;
	case 1:  /*  1|0001|1 */
	  pos = WlzGeomObjLineSegIntersect3D(obj,
					     nodes[0]->pos, nodes[3]->pos,
					     tol, 0, mtd, NULL);
	  nodes[0]->pos = pos;
	  nodes[0]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 2:  /*  2|0010|1 */
	  pos = WlzGeomObjLineSegIntersect3D(obj,
	                                     nodes[1]->pos, nodes[0]->pos,
	  				     tol, 0, mtd, NULL);
	  nodes[1]->pos = pos;
	  nodes[1]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 4:  /*  4|0100|1 */
	  pos = WlzGeomObjLineSegIntersect3D(obj,
	  				     nodes[2]->pos, nodes[1]->pos,
	  				     tol, 0, mtd, NULL);
	  nodes[2]->pos = pos;
	  nodes[2]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 8:  /*  8|1000|1 */
	  pos = WlzGeomObjLineSegIntersect3D(obj,
	  				     nodes[3]->pos, nodes[2]->pos,
	  				     tol, 0, mtd, NULL);
	  nodes[3]->pos = pos;
	  nodes[3]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 3:  /*  3|0011|2 */
	  for(idN = 0; idN < 2; idN += 1)
	  {
	    pos = WlzGeomObjLineSegIntersect3D(obj,
	                                       nodes[idN]->pos, nodes[2]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 5:  /*  5|0101|2 */
	  for(idN = 0; idN < 3; idN += 2)
	  {
	    pos = WlzGeomObjLineSegIntersect3D(obj,
	                                       nodes[idN]->pos, nodes[3]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 6:  /*  6|0110|2 */
	  for(idN = 1; idN < 3; ++idN)
	  {
	    pos = WlzGeomObjLineSegIntersect3D(obj,
	                                       nodes[idN]->pos, nodes[0]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
        case 9:  /*  9|1001|2 */
	  for(idN = 0; idN < 4; idN += 3)
	  {
	    pos = WlzGeomObjLineSegIntersect3D(obj,
	                                       nodes[idN]->pos, nodes[1]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 10: /* 10|1010|2 */
	  for(idN = 1; idN < 4; idN += 2)
	  {
	    pos = WlzGeomObjLineSegIntersect3D(obj,
	                                       nodes[idN]->pos, nodes[0]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 12: /* 12|1100|2 */
	  for(idN = 2; idN < 4; idN += 1)
	  {
	    pos = WlzGeomObjLineSegIntersect3D(obj,
	                                       nodes[idN]->pos, nodes[1]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 7:  /*  7|0111|3 */
	  for(idN = 0; idN < 3; idN += 1)
	  {
	    pos = WlzGeomObjLineSegIntersect3D(obj,
	                                       nodes[idN]->pos, nodes[3]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 11: /* 11|1011|3 */
	  for(idN = 0; idN < 3; idN += 1)
	  {
	    int idM;

	    idM = (idN + 3) % 4;
	    pos = WlzGeomObjLineSegIntersect3D(obj,
	                                       nodes[idM]->pos, nodes[2]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idM]->pos = pos;
	    nodes[idM]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 13: /* 13|1101|3 */
	  for(idN = 0; idN < 3; idN += 1)
	  {
	    int idM;

	    idM = (idN + 2) % 4;
	    pos = WlzGeomObjLineSegIntersect3D(obj,
	                                       nodes[idM]->pos, nodes[1]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idM]->pos = pos;
	    nodes[idM]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 14: /* 14|1110|3 */
	  for(idN = 1; idN < 4; idN += 1)
	  {
	    pos = WlzGeomObjLineSegIntersect3D(obj,
	                                       nodes[idN]->pos, nodes[0]->pos,
					       tol, 0, mtd, NULL);
	    nodes[idN]->pos = pos;
	    nodes[idN]->flags |= WLZ_CMESH_NOD_FLAG_BOUNDARY;
	  }
	  elm->flags = WLZ_CMESH_ELM_FLAG_BOUNDARY;
	  break;
	case 15: /* 15|1111|4 */ /* FALLTHROUGH */
	default:
	  elm->flags = WLZ_CMESH_ELM_FLAG_OUTSIDE;
	  break;
      }
    }
  }
  /* Pass 2: Delete all elements flaged as outside or with very small/
   * negative volume. */
  for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
  {
    elm = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
    if(elm->idx >= 0)
    {
      if((elm->flags & WLZ_CMESH_ELM_FLAG_OUTSIDE) != 0)
      {
        (void )WlzCMeshDelElm3D(mesh, elm);
      }
      else if((elm->flags & WLZ_CMESH_ELM_FLAG_BOUNDARY) != 0)
      {
        double sV6;

	nodes[0] = WLZ_CMESH_ELM3D_GET_NODE_0(elm);
	nodes[1] = WLZ_CMESH_ELM3D_GET_NODE_1(elm);
	nodes[2] = WLZ_CMESH_ELM3D_GET_NODE_2(elm);
	nodes[3] = WLZ_CMESH_ELM3D_GET_NODE_3(elm);
	sV6 = WlzGeomTetraSnVolume6(nodes[0]->pos, nodes[1]->pos,
	                            nodes[2]->pos, nodes[3]->pos);
        if(sV6 < WLZ_MESH_TOLERANCE_SQ)
	{
          (void )WlzCMeshDelElm3D(mesh, elm);
	}
      }
    }
  }
#ifdef WLZ_CMESH_DEBUG_VERIFY_CONFORM
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify3D(mesh, NULL, 1, stderr);
  }
#endif /* WLZ_CMESH_DEBUG_VERIFY_CONFORM */
  return(errNum);
}

/*!
* \return	Square of the minimum edge length for the element,
*		this will be negative for invalid elements.
* \ingroup	WlzMesh
* \brief	Computes the square of the minimum edge length for
*		the element.
* \param	elm			Given element.
*/
double 		WlzCMeshElmMinEdgLnSq2D(WlzCMeshElm2D *elm)
{
  double	lenSq,
  		minLenSq = -1.0;
  WlzDVertex2	p0;
  WlzCMeshNod2D *nodBuf[3];

  if(elm && (elm->idx >= 0))
  {
    /* Collect the nodes of the element. */
    nodBuf[0] = elm->edu[0].nod;
    nodBuf[1] = elm->edu[1].nod;
    nodBuf[2] = elm->edu[2].nod;
    /* Compute and compare edge lengths. */
    WLZ_VTX_2_SUB(p0, nodBuf[0]->pos, nodBuf[1]->pos);
    minLenSq = WLZ_VTX_2_SQRLEN(p0);
    WLZ_VTX_2_SUB(p0, nodBuf[0]->pos, nodBuf[2]->pos);
    lenSq = WLZ_VTX_2_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    WLZ_VTX_2_SUB(p0, nodBuf[1]->pos, nodBuf[2]->pos);
    lenSq = WLZ_VTX_2_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
  }
  return(minLenSq);
}

/*!
* \ingroup	WlzMesh
* \brief	Computes the square of the minimum and maximum edge length for
*		the given element.
* \param	elm			Given element, must be valid.
* \param	dstMinSq		Destination pointer for minimum squared
* 					edge length, may be NULL.
* \param	dstMaxSq		Destination pointer for maximum squared
* 					edge length, may be NULL.
*/
void 		WlzCMeshElmMinMaxEdgLnSq3D(WlzCMeshElm3D *elm,
                                           double *dstMinSq, double *dstMaxSq)
{
  int		idx;
  double	lenSq,
  		minLenSq,
		maxLenSq;
  WlzDVertex3	p0;
  WlzCMeshNod3D *nodBuf[4];
  const int	nodTbl[6][2] =
                {
		  {0, 1},
		  {0, 2},
		  {0, 3},
		  {1, 2},
		  {1, 3},
		  {2, 3}
		};

  /* Collect the nodes of the element. */
  nodBuf[0] = WLZ_CMESH_ELM3D_GET_NODE_0(elm);
  nodBuf[1] = WLZ_CMESH_ELM3D_GET_NODE_1(elm);
  nodBuf[2] = WLZ_CMESH_ELM3D_GET_NODE_2(elm);
  nodBuf[3] = WLZ_CMESH_ELM3D_GET_NODE_3(elm);
  /* Compute and compare edge lengths. */
  WLZ_VTX_3_SUB(p0, nodBuf[nodTbl[0][0]]->pos, nodBuf[nodTbl[0][1]]->pos);
  minLenSq = maxLenSq = WLZ_VTX_3_SQRLEN(p0);
  for(idx = 1; idx < 6; ++idx)
  {
    WLZ_VTX_3_SUB(p0,
		  nodBuf[nodTbl[idx][0]]->pos, nodBuf[nodTbl[idx][1]]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    else if(lenSq > maxLenSq)
    {
      maxLenSq = lenSq;
    }
  }
  if(dstMinSq)
  {
    *dstMinSq = minLenSq;
  }
  if(dstMinSq)
  {
    *dstMaxSq = maxLenSq;
  }
}

/*!
* \return	Square of the minimum edge length for the element,
*		this will be negative for invalid elements.
* \ingroup	WlzMesh
* \brief	Computes the square of the minimum edge length for
*		the element.
* \param	elm			Given element.
*/
double 		WlzCMeshElmMinEdgLnSq3D(WlzCMeshElm3D *elm)
{
  double	lenSq,
  		minLenSq = -1.0;
  WlzDVertex3	p0;
  WlzCMeshNod3D *nodBuf[4];

  if(elm && (elm->idx >= 0))
  {
    /* Collect the nodes of the element. */
    nodBuf[0] = WLZ_CMESH_ELM3D_GET_NODE_0(elm);
    nodBuf[1] = WLZ_CMESH_ELM3D_GET_NODE_1(elm);
    nodBuf[2] = WLZ_CMESH_ELM3D_GET_NODE_2(elm);
    nodBuf[3] = WLZ_CMESH_ELM3D_GET_NODE_3(elm);
    /* Compute and compare edge lengths. */
    WLZ_VTX_3_SUB(p0, nodBuf[0]->pos, nodBuf[1]->pos);
    minLenSq = WLZ_VTX_3_SQRLEN(p0);
    WLZ_VTX_3_SUB(p0, nodBuf[0]->pos, nodBuf[2]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    WLZ_VTX_3_SUB(p0, nodBuf[0]->pos, nodBuf[3]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    WLZ_VTX_3_SUB(p0, nodBuf[1]->pos, nodBuf[2]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    WLZ_VTX_3_SUB(p0, nodBuf[1]->pos, nodBuf[3]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
    WLZ_VTX_3_SUB(p0, nodBuf[2]->pos, nodBuf[3]->pos);
    lenSq = WLZ_VTX_3_SQRLEN(p0);
    if(lenSq < minLenSq)
    {
      minLenSq = lenSq;
    }
  }
  return(minLenSq);
}

/*!
* \ingroup	WlzMesh
* \brief	Free's the grid cells of a 2D mesh.
* \param	mesh			Given 2D mesh.
*/
static void	  WlzCMeshFreeGridCells2D(WlzCMesh2D *mesh)
{
  if((mesh != NULL) && (mesh->cGrid.cells != NULL))
  {
    AlcFree(*(mesh->cGrid.cells));
    AlcFree(mesh->cGrid.cells);
    mesh->cGrid.cells = NULL;
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Free's the grid cells of a 2D5 mesh.
* \param	mesh			Given 2D5 mesh.
*/
static void	  WlzCMeshFreeGridCells2D5(WlzCMesh2D5 *mesh)
{
  if((mesh != NULL) && (mesh->cGrid.cells != NULL))
  {
    AlcFree(**(mesh->cGrid.cells));
    AlcFree(*(mesh->cGrid.cells));
    AlcFree(mesh->cGrid.cells);
    mesh->cGrid.cells = NULL;
  }
}

/*!
* \ingroup	WlzMesh
* \brief	Free's the grid cells of a 3D mesh.
* \param	mesh			Given 3D mesh.
*/
static void	  WlzCMeshFreeGridCells3D(WlzCMesh3D *mesh)
{
  if((mesh != NULL) && (mesh->cGrid.cells != NULL))
  {
    AlcFree(**(mesh->cGrid.cells));
    AlcFree(*(mesh->cGrid.cells));
    AlcFree(mesh->cGrid.cells);
    mesh->cGrid.cells = NULL;
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Allocates the grid cells of a 2D mesh.
* \param	mesh			Given 2D mesh.
*/
static WlzErrorNum WlzCMeshAllocGridCells2D(WlzCMesh2D *mesh)
{
  int		idy;
  WlzCMeshCell2D *cellP;
  WlzCMeshCellGrid2D *cGrid;
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    cGrid = &(mesh->cGrid);
    if(((cellP = (WlzCMeshCell2D *)
                 AlcCalloc(cGrid->nCells.vtY * cGrid->nCells.vtX,
			   sizeof(WlzCMeshCell2D))) == NULL) ||
       ((cGrid->cells = (WlzCMeshCell2D **)
			AlcMalloc(cGrid->nCells.vtY *
				  sizeof(WlzCMeshCell2D *))) == NULL))
    {
      AlcFree(cellP);
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    for(idy = 0; idy < cGrid->nCells.vtY; ++idy)
    {
      *(cGrid->cells + idy) = cellP;
      cellP += cGrid->nCells.vtX;
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Allocates the grid cells of a 2D5 mesh.
* \param	mesh			Given 2D5 mesh.
*/
static WlzErrorNum WlzCMeshAllocGridCells2D5(WlzCMesh2D5 *mesh)
{
  int		idy,
  		idz;
  WlzCMeshCellGrid2D5 *cGrid;
  WlzCMeshCell2D5 *cellP = NULL;
  WlzCMeshCell2D5 **cellPP = NULL;
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    cGrid = &(mesh->cGrid);
    if(((cellP = (WlzCMeshCell2D5 *)
                 AlcCalloc(cGrid->nCells.vtZ * cGrid->nCells.vtY *
		           cGrid->nCells.vtX,
			   sizeof(WlzCMeshCell2D5))) == NULL) ||
       ((cellPP = (WlzCMeshCell2D5 **)
			AlcMalloc(cGrid->nCells.vtZ * cGrid->nCells.vtY *
				  sizeof(WlzCMeshCell2D5 *))) == NULL) ||
       ((cGrid->cells = (WlzCMeshCell2D5 ***)
			AlcMalloc(cGrid->nCells.vtZ *
				  sizeof(WlzCMeshCell2D5 **))) == NULL))
    {
      AlcFree(cellP);
      AlcFree(cellPP);
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    for(idz = 0; idz < cGrid->nCells.vtZ; ++idz)
    {
      *(cGrid->cells + idz) = cellPP;
      for(idy = 0; idy < cGrid->nCells.vtY; ++idy)
      {
	*(*(cGrid->cells + idz) + idy) = cellP;
	cellP += cGrid->nCells.vtX;
      }
      cellPP += cGrid->nCells.vtY;
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Allocates the grid cells of a 3D mesh.
* \param	mesh			Given 3D mesh.
*/
static WlzErrorNum WlzCMeshAllocGridCells3D(WlzCMesh3D *mesh)
{
  int		idy,
  		idz;
  WlzCMeshCell3D *cellP = NULL;
  WlzCMeshCell3D **cellPP = NULL;
  WlzCMeshCellGrid3D *cGrid = NULL;
  WlzErrorNum   errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    cGrid = &(mesh->cGrid);
    if(((cellP = (WlzCMeshCell3D *)
                 AlcCalloc(cGrid->nCells.vtZ * cGrid->nCells.vtY *
		           cGrid->nCells.vtX,
			   sizeof(WlzCMeshCell3D))) == NULL) ||
       ((cellPP = (WlzCMeshCell3D **)
			AlcMalloc(cGrid->nCells.vtZ * cGrid->nCells.vtY *
				  sizeof(WlzCMeshCell3D *))) == NULL) ||
       ((cGrid->cells = (WlzCMeshCell3D ***)
			AlcMalloc(cGrid->nCells.vtZ *
				  sizeof(WlzCMeshCell3D **))) == NULL))
    {
      AlcFree(cellP);
      AlcFree(cellPP);
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    for(idz = 0; idz < cGrid->nCells.vtZ; ++idz)
    {
      *(cGrid->cells + idz) = cellPP;
      for(idy = 0; idy < cGrid->nCells.vtY; ++idy)
      {
	*(*(cGrid->cells + idz) + idy) = cellP;
	cellP += cGrid->nCells.vtX;
      }
      cellPP += cGrid->nCells.vtY;
    }
  }
  return(errNum);
}

/*!
* \return	Wlz error code.
* \ingroup	WlzMesh
* \brief	Allocates a new cell grid and then reassigns the nodes
*		to the cells.
* \param	mesh			The mesh.
* \param	newNumNod		New expected number of nodes.
*/
WlzErrorNum 	WlzCMeshReassignGridCells2D(WlzCMesh2D *mesh, int newNumNod)
{
  int		idE,
  		idN;
  WlzDVertex2	mSz;
  WlzCMeshNod2D	*nod;
  WlzCMeshElm2D	*elm;
  AlcBlockStack *bStack;
  WlzCMeshCellGrid2D *cGrid;
  WlzCMeshCellElm2D *cElm;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	nodBSz = 1024; 	  /* Minimum number of nodes for which to
                                     allocate space. */
  const double	nodPerCell = 2.0; /* Number of nodes per cell on average. */

  if(newNumNod <= 0)
  {
    newNumNod = (mesh->res.nod.numEnt < nodBSz)?
                nodBSz: mesh->res.nod.numEnt;
  }
  /* This assumes that the mesh nodes will be evenly distributed over
   * the LBT domain (which they're not). */
  mSz.vtX = ceil(mesh->bBox.xMax - mesh->bBox.xMin + 1.0);
  mSz.vtY = ceil(mesh->bBox.yMax - mesh->bBox.yMin + 1.0);
  cGrid = &(mesh->cGrid);
  cGrid->cellSz = WlzCMeshCompGridBSz2D(newNumNod, nodPerCell, mSz);
  cGrid->nCells.vtX = (int )ceil(mSz.vtX / cGrid->cellSz) + 1;
  cGrid->nCells.vtY = (int )ceil(mSz.vtY / cGrid->cellSz) + 1;
  /* Reclaim all cell elements. */
  cGrid->freeCE = NULL;
  bStack = cGrid->allCE;
  while(bStack != NULL)
  {
    cElm = (WlzCMeshCellElm2D *)(bStack->elements);
    for(idE = 0; idE < bStack->maxElm; ++idE)
    {
      cElm->next = cGrid->freeCE;
      cGrid->freeCE = cElm;
      ++cElm;
    }
    bStack = bStack->next;
  }
  /* Reallocate the grid cells. */
  WlzCMeshFreeGridCells2D(mesh);
  errNum = WlzCMeshAllocGridCells2D(mesh);
  /* Add all nodes to grid of cells. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	WlzCMeshAddNodToGrid2D(mesh, nod);
      }
    }
  }
  /* Add all elements to grid of cells. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
    {
      elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
	if((errNum = WlzCMeshAddElmToGrid2D(mesh, elm)) != WLZ_ERR_NONE)
	{
	  break;
	}
      }
    }
  }
  return(errNum);
}

/*!
* \return	Wlz error code.
* \ingroup	WlzMesh
* \brief	Allocates a new cell grid and then reassigns the nodes
*		and elements to the cells.
* \param	mesh			The mesh.
* \param	newNumNod		New expected number of nodes.
*					If zero the current number of nodes
*					or a small number (1024) will be used
*					(which ever is the greater).
*/
WlzErrorNum 	WlzCMeshReassignGridCells2D5(WlzCMesh2D5 *mesh, int newNumNod)
{
  int		idE,
  		idN;
  WlzDVertex3	mSz;
  WlzCMeshNod2D5 *nod;
  WlzCMeshElm2D5 *elm;
  AlcBlockStack *bStack;
  WlzCMeshCellGrid2D5 *cGrid;
  WlzCMeshCellElm2D5 *cElm;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	nodBSz = 1024; 	  /* Minimum number of nodes for which to
                                     allocate space. */
  const double	nodPerCell = 1.0; /* Number of nodes per cell on average. */

  if(newNumNod <= 0)
  {
    newNumNod = (mesh->res.nod.numEnt < nodBSz)?
                nodBSz: mesh->res.nod.numEnt;
  }
  /* This assumes that the mesh nodes will be evenly distributed over
   * the LBT domain (which they're not). */
  mSz.vtX = ceil(mesh->bBox.xMax - mesh->bBox.xMin + 1.0);
  mSz.vtY = ceil(mesh->bBox.yMax - mesh->bBox.yMin + 1.0);
  mSz.vtZ = ceil(mesh->bBox.zMax - mesh->bBox.zMin + 1.0);
  cGrid = &(mesh->cGrid);
  cGrid->cellSz = WlzCMeshCompGridBSz2D5(newNumNod, nodPerCell, mSz);
  cGrid->nCells.vtX = (int )ceil(mSz.vtX / cGrid->cellSz) + 1;
  cGrid->nCells.vtY = (int )ceil(mSz.vtY / cGrid->cellSz) + 1;
  cGrid->nCells.vtZ = (int )ceil(mSz.vtZ / cGrid->cellSz) + 1;
  /* Reclaim all cell elements. */
  cGrid->freeCE = NULL;
  bStack = cGrid->allCE;
  while(bStack != NULL)
  {
    cElm = (WlzCMeshCellElm2D5 *)(bStack->elements);
    for(idE = 0; idE < bStack->maxElm; ++idE)
    {
      cElm->next = cGrid->freeCE;
      cGrid->freeCE = cElm;
      ++cElm;
    }
    bStack = bStack->next;
  }
  /* Reallocate the grid cells. */
  WlzCMeshFreeGridCells2D5(mesh);
  errNum = WlzCMeshAllocGridCells2D5(mesh);
  /* Add all nodes to grid of cells. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod2D5 *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	WlzCMeshAddNodToGrid2D5(mesh, nod);
      }
    }
  }
  /* Add all elements to grid of cells. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
    {
      elm = (WlzCMeshElm2D5 *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
	if((errNum = WlzCMeshAddElmToGrid2D5(mesh, elm)) != WLZ_ERR_NONE)
	{
	  break;
	}
      }
    }
  }
  return(errNum);
}

/*!
* \return	Wlz error code.
* \ingroup	WlzMesh
* \brief	Allocates a new cell grid and then reassigns the nodes
*		and elements to the cells.
* \param	mesh			The mesh.
* \param	newNumNod		New expected number of nodes.
*					If zero the current number of nodes
*					or a small number (1024) will be used
*					(which ever is the greater).
*/
WlzErrorNum 	WlzCMeshReassignGridCells3D(WlzCMesh3D *mesh, int newNumNod)
{
  int		idE,
  		idN;
  WlzDVertex3	mSz;
  WlzCMeshNod3D	*nod;
  WlzCMeshElm3D	*elm;
  AlcBlockStack *bStack;
  WlzCMeshCellGrid3D *cGrid;
  WlzCMeshCellElm3D *cElm;
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  const int	nodBSz = 1024; 	  /* Minimum number of nodes for which to
                                     allocate space. */
  const double	nodPerCell = 1.0; /* Number of nodes per cell on average. */

  if(newNumNod <= 0)
  {
    newNumNod = (mesh->res.nod.numEnt < nodBSz)?
                nodBSz: mesh->res.nod.numEnt;
  }
  /* This assumes that the mesh nodes will be evenly distributed over
   * the LBT domain (which they're not). */
  mSz.vtX = ceil(mesh->bBox.xMax - mesh->bBox.xMin + 1.0);
  mSz.vtY = ceil(mesh->bBox.yMax - mesh->bBox.yMin + 1.0);
  mSz.vtZ = ceil(mesh->bBox.zMax - mesh->bBox.zMin + 1.0);
  cGrid = &(mesh->cGrid);
  cGrid->cellSz = WlzCMeshCompGridBSz3D(newNumNod, nodPerCell, mSz);
  cGrid->nCells.vtX = (int )ceil(mSz.vtX / cGrid->cellSz) + 1;
  cGrid->nCells.vtY = (int )ceil(mSz.vtY / cGrid->cellSz) + 1;
  cGrid->nCells.vtZ = (int )ceil(mSz.vtZ / cGrid->cellSz) + 1;
  /* Reclaim all cell elements. */
  cGrid->freeCE = NULL;
  bStack = cGrid->allCE;
  while(bStack != NULL)
  {
    cElm = (WlzCMeshCellElm3D *)(bStack->elements);
    for(idE = 0; idE < bStack->maxElm; ++idE)
    {
      cElm->next = cGrid->freeCE;
      cGrid->freeCE = cElm;
      ++cElm;
    }
    bStack = bStack->next;
  }
  /* Reallocate the grid cells. */
  WlzCMeshFreeGridCells3D(mesh);
  errNum = WlzCMeshAllocGridCells3D(mesh);
  /* Add all nodes to grid of cells. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      nod = (WlzCMeshNod3D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	WlzCMeshAddNodToGrid3D(mesh, nod);
      }
    }
  }
  /* Add all elements to grid of cells. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
    {
      elm = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
	if((errNum = WlzCMeshAddElmToGrid3D(mesh, elm)) != WLZ_ERR_NONE)
	{
	  break;
	}
      }
    }
  }
  return(errNum);
}

/*!
* \return	Cell size.
* \ingroup	WlzMesh
* \brief	Computes the cell size for the 2D mesh node location grid.
*		The function assumes that nodes are evenly distributed over
*		the bounding box of the mesh and uses simple scaling to
*		compute  the cell size. The function should be called for
*		the x, and y components.
* \param	nN			Total number of nodes in the mesh.
* \param	nPC			Number of nodes per cell.
* \param	mSz			Mesh size.
*/
static double	WlzCMeshCompGridBSz2D(int nN, double nPC, WlzDVertex2 mSz)
{
  double	bSz;

  bSz = sqrt(fabs((nPC * mSz.vtX * mSz.vtY)/(nN + 1.0)));
  return(bSz);
}

/*!
* \return	Bucket size.
* \ingroup	WlzMesh
* \brief	Computes the bucket size for the 2D5 mesh node location grid.
*		The function assumes that nodes are evenly distributed over
*		the bounding box of the mesh and uses simple scaling to
*		compute  the bucket size. The function should be called for
*		the x, and y components.
* \param	Nn			Total number of nodes in the mesh.
* \param	nPC			Number of nodes per cell.
* \param	mSz			Mesh size.
*/
static double 	WlzCMeshCompGridBSz2D5(int nN, double nPC, WlzDVertex3 mSz)
{
  double	bSz;

  bSz = pow(fabs((nPC * mSz.vtX * mSz.vtY * mSz.vtZ)/(nN + 1.0)),
            1.0 / 3.0);
  return(bSz);
}

/*!
* \return	Bucket size.
* \ingroup	WlzMesh
* \brief	Computes the bucket size for the 3D mesh node location grid.
*		The function assumes that nodes are evenly distributed over
*		the bounding box of the mesh and uses simple scaling to
*		compute  the bucket size. The function should be called for
*		the x, and y components.
* \param	Nn			Total number of nodes in the mesh.
* \param	nPC			Number of nodes per cell.
* \param	mSz			Mesh size.
*/
static double 	WlzCMeshCompGridBSz3D(int nN, double nPC, WlzDVertex3 mSz)
{
  double	bSz;

  bSz = pow(fabs((nPC * mSz.vtX * mSz.vtY * mSz.vtZ)/(nN + 1.0)),
            1.0 / 3.0);
  return(bSz);
}

/*!
* \return	Mesh grid bucket indices.
* \ingroup	WlzMesh
* \brief	Computes the mesh cell grid indices for a given
*		vertex position.
* \param	mesh			The mesh.
* \param	vtx			Given vertex.
*/
static WlzIVertex2 WlzCMeshCellIdxVtx2D(WlzCMesh2D *mesh, WlzDVertex2 vtx)
{
  WlzIVertex2	idx;

  idx.vtX = (int )((vtx.vtX - mesh->bBox.xMin) / mesh->cGrid.cellSz);
  idx.vtX = WLZ_CLAMP(idx.vtX, 0,  mesh->cGrid.nCells.vtX - 1);
  idx.vtY = (int )((vtx.vtY - mesh->bBox.yMin) / mesh->cGrid.cellSz);
  idx.vtY = WLZ_CLAMP(idx.vtY, 0,  mesh->cGrid.nCells.vtY - 1);
  return(idx);
}

/*!
* \return	Mesh grid bucket indices.
* \ingroup	WlzMesh
* \brief	Computes the mesh cell grid indices for a given
*		vertex position.
* \param	mesh			The mesh.
* \param	vtx			Given vertex.
*/
static WlzIVertex3 WlzCMeshCellIdxVtx2D5(WlzCMesh2D5 *mesh, WlzDVertex3 vtx)
{
  WlzIVertex3	idx;

  idx.vtX = (int )((vtx.vtX - mesh->bBox.xMin) / mesh->cGrid.cellSz);
  idx.vtX = WLZ_CLAMP(idx.vtX, 0,  mesh->cGrid.nCells.vtX - 1);
  idx.vtY = (int )((vtx.vtY - mesh->bBox.yMin) / mesh->cGrid.cellSz);
  idx.vtY = WLZ_CLAMP(idx.vtY, 0,  mesh->cGrid.nCells.vtY - 1);
  idx.vtZ = (int )((vtx.vtZ - mesh->bBox.zMin) / mesh->cGrid.cellSz);
  idx.vtZ = WLZ_CLAMP(idx.vtZ, 0,  mesh->cGrid.nCells.vtZ - 1);
  return(idx);
}

/*!
* \return	Mesh grid bucket indices.
* \ingroup	WlzMesh
* \brief	Computes the mesh cell grid indices for a given
*		vertex position.
* \param	mesh			The mesh.
* \param	vtx			Given vertex.
*/
static WlzIVertex3 WlzCMeshCellIdxVtx3D(WlzCMesh3D *mesh, WlzDVertex3 vtx)
{
  WlzIVertex3	idx;

  idx.vtX = (int )((vtx.vtX - mesh->bBox.xMin) / mesh->cGrid.cellSz);
  idx.vtX = WLZ_CLAMP(idx.vtX, 0,  mesh->cGrid.nCells.vtX - 1);
  idx.vtY = (int )((vtx.vtY - mesh->bBox.yMin) / mesh->cGrid.cellSz);
  idx.vtY = WLZ_CLAMP(idx.vtY, 0,  mesh->cGrid.nCells.vtY - 1);
  idx.vtZ = (int )((vtx.vtZ - mesh->bBox.zMin) / mesh->cGrid.cellSz);
  idx.vtZ = WLZ_CLAMP(idx.vtZ, 0,  mesh->cGrid.nCells.vtZ - 1);
  return(idx);
}

/*!
* \return	Non zero if there is an existing node at the given position.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_MESH_TOLERANCE distance) of
*		the given vertex. This function also gives access to the
*		grid cell containing the node.
* \param	mesh			The mesh.
* \param	pos			Given node position.
* \param	tol			Tollerance to use when finding
* 					mesh node.
* \param	dstNod			Destination pointer for the matched
*					node which will be NULL if there
*					is no node at the given position.
*					Must not be NULL.
*/
int	 	WlzCMeshLocateNod2D(WlzCMesh2D *mesh, 
				    WlzDVertex2 pos,
				    double tol,
				    WlzCMeshNod2D **dstNod)
{
  int		found = 0;
  double	delta;
  WlzDVertex2	pos0,
  		pos1;
  WlzIVertex2	idx,
  		idxMin,
		idxMax;
  WlzCMeshCell2D *cell;
  WlzCMeshNod2D	*nod;
  const double	eps = 0.001;

  /* Search within a range of cells because the vertex may be on the
   * edge of a cell. */
  delta = eps * mesh->cGrid.cellSz;
  pos0.vtX = pos.vtX - delta;
  pos0.vtY = pos.vtY - delta;
  pos1.vtX = pos.vtX + delta;
  pos1.vtY = pos.vtY + delta;
  idxMin = WlzCMeshCellIdxVtx2D(mesh, pos0);
  idxMax = WlzCMeshCellIdxVtx2D(mesh, pos1);
  for(idx.vtY = idxMin.vtY; idx.vtY <= idxMax.vtY; ++idx.vtY)
  {
    for(idx.vtX = idxMin.vtX; idx.vtX <= idxMax.vtX; ++idx.vtX)
    {
      cell = *(mesh->cGrid.cells + idx.vtY) + idx.vtX;
      nod = cell->nod;
      while(nod != NULL)
      {
	if(WLZ_VTX_2_EQUAL(nod->pos, pos, tol))
	{
	  found = 1;
	  goto FOUND;
	}
	nod = nod->next;
      }
    }
  }
FOUND:
  *dstNod = (found)? nod: NULL;
  return(found);
}

/*!
* \return	Non zero if there is an existing node at the given position.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_MESH_TOLERANCE distance) of
*		the given vertex. This function also gives access to the
*		grid cell containing the node.
* \param	mesh			The mesh.
* \param	pos			Given node position.
* \param	tol			Tollerance to use when finding
* 					mesh node.
* \param	dstNod			Destination pointer for the matched
*					node which will be NULL if there
*					is no node at the given position.
*					Must not be NULL.
*/
int	 	WlzCMeshLocateNod2D5(WlzCMesh2D5 *mesh, 
				     WlzDVertex3 pos,
				     double tol,
				     WlzCMeshNod2D5 **dstNod)
{
  int		found = 0;
  double	delta;
  WlzDVertex3	pos0,
  		pos1;
  WlzIVertex3	idx,
  		idxMin,
		idxMax;
  WlzCMeshCell2D5 *cell;
  WlzCMeshNod2D5 *nod;
  const double	eps = 0.001;

  /* Search within a range of cells because the vertex may be on the
   * edge of a cell. */
  delta = eps * mesh->cGrid.cellSz;
  pos0.vtX = pos.vtX - delta;
  pos0.vtY = pos.vtY - delta;
  pos0.vtZ = pos.vtZ - delta;
  pos1.vtX = pos.vtX + delta;
  pos1.vtY = pos.vtY + delta;
  pos1.vtZ = pos.vtZ + delta;
  idxMin = WlzCMeshCellIdxVtx2D5(mesh, pos0);
  idxMax = WlzCMeshCellIdxVtx2D5(mesh, pos1);
  for(idx.vtZ = idxMin.vtZ; idx.vtZ <= idxMax.vtZ; ++idx.vtZ)
  {
    for(idx.vtY = idxMin.vtY; idx.vtY <= idxMax.vtY; ++idx.vtY)
    {
      for(idx.vtX = idxMin.vtX; idx.vtX <= idxMax.vtX; ++idx.vtX)
      {
	cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
	nod = cell->nod;
	while(nod != NULL)
	{
	  if(WLZ_VTX_3_EQUAL(nod->pos, pos, tol))
	  {
	    found = 1;
	    goto FOUND;
	  }
	  nod = nod->next;
	}
      }
    }
  }
FOUND:
  *dstNod = (found)? nod: NULL;
  return(found);
}

/*!
* \return	Non zero if there is an existing node at the given position.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_MESH_TOLERANCE distance) of
*		the given vertex. This function also gives access to the
*		grid cell containing the node.
* \param	mesh			The mesh.
* \param	pos			Given node position.
* \param	dstGPos			Destination pointer for the grid
*					position. Must not be NULL.
* \param	dstPrev			Destination pointer for the previous
*					node in the cell's linked list,
*					which will be NULL if either the
*					cell is empty or the matched node
*					is the first in the cell. Must not
*					be NULL.
* \param	tol			Tollerance to use when finding
* 					mesh node.
* \param	dstNod			Destination pointer for the matched
*					node which will be NULL if there
*					is no node at the given position.
*					Must not be NULL.
*/
int	 	WlzCMeshLocateNod3D(WlzCMesh3D *mesh, 
				    WlzDVertex3 pos,
				    WlzIVertex3 *dstGPos,
				    WlzCMeshNod3D **dstPrev,
				    double tol,
				    WlzCMeshNod3D **dstNod)
{
  int		found = 0;
  double	delta;
  WlzDVertex3	pos0,
  		pos1;
  WlzIVertex3	idx,
  		idxMin,
		idxMax;
  WlzCMeshCell3D *cell;
  WlzCMeshNod3D	*nod;
  const double	eps = 0.001;

  /* Search within a range of cells because the vertex may be on the
   * edge of a cell. */
  delta = eps * mesh->cGrid.cellSz;
  pos0.vtX = pos.vtX - delta;
  pos0.vtY = pos.vtY - delta;
  pos0.vtZ = pos.vtZ - delta;
  pos1.vtX = pos.vtX + delta;
  pos1.vtY = pos.vtY + delta;
  pos1.vtZ = pos.vtZ + delta;
  idxMin = WlzCMeshCellIdxVtx3D(mesh, pos0);
  idxMax = WlzCMeshCellIdxVtx3D(mesh, pos1);
  for(idx.vtZ = idxMin.vtZ; idx.vtZ <= idxMax.vtZ; ++idx.vtZ)
  {
    for(idx.vtY = idxMin.vtY; idx.vtY <= idxMax.vtY; ++idx.vtY)
    {
      for(idx.vtX = idxMin.vtX; idx.vtX <= idxMax.vtX; ++idx.vtX)
      {
	cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
	nod = cell->nod;
	while(nod != NULL)
	{
	  if(WLZ_VTX_3_EQUAL(nod->pos, pos, tol))
	  {
	    found = 1;
	    goto FOUND;
	  }
	  nod = nod->next;
	}
      }
    }
  }
FOUND:
  *dstNod = (found)? nod: NULL;
  return(found);
}

/*!
* \return	Matched node or NULL if no node is matched.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_MESH_TOLERANCE distance) of
*		the given vertex.
* \param	mesh			The mesh.
* \param	nPos			Given vertex position.
* \param	tol			Match tolerance.
*/
WlzCMeshNod2D 	*WlzCMeshMatchNod2D(WlzCMesh2D *mesh, WlzDVertex2 nPos,
				    double tol)
{
  WlzCMeshNod2D	*mNod;

  (void )WlzCMeshLocateNod2D(mesh, nPos, tol, &mNod);
  return(mNod);
}

/*!
* \return	Matched node or NULL if no node is matched.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_MESH_TOLERANCE distance) of
*		the given vertex.
* \param	mesh			The mesh.
* \param	nPos			Given vertex position.
* \param	tol			Match tolerance.
*/
WlzCMeshNod2D5 	*WlzCMeshMatchNod2D5(WlzCMesh2D5 *mesh, WlzDVertex3 nPos,
				     double tol)
{
  WlzCMeshNod2D5 *mNod;

  (void )WlzCMeshLocateNod2D5(mesh, nPos, tol, &mNod);
  return(mNod);
}

/*!
* \return	Matched node or NULL if no node is matched.
* \ingroup	WlzMesh
* \brief	Locates the matching node and for the given vertex
*		position. The matched node is the mesh node which has the
*		same position (within WLZ_MESH_TOLERANCE distance) of
*		the given vertex.
* \param	mesh			The mesh.
* \param	nPos			Given vertex position.
* \param	tol			Match tolerance.
*/
WlzCMeshNod3D 	*WlzCMeshMatchNod3D(WlzCMesh3D *mesh, WlzDVertex3 nPos,
				     double tol)
{
  WlzIVertex3	gPos;
  WlzCMeshNod3D	*prev,
  		*mNod;

  (void )WlzCMeshLocateNod3D(mesh, nPos, &gPos, &prev, tol, &mNod);
  return(mNod);
}

/*!
* \return	Number of matched nodes.
* \ingroup	WlzMesh
* \brief	Locates the nodes matching the given vertex positions.
*		The matched nodes are the mesh nodes which have the
*		same positions (within WLZ_MESH_TOLERANCE distance) of
*		the given vertices.
* \param	mesh			The mesh.
* \param	nNod			Number of node positions to match.
* \param	nPos			Node positions.
* \param	tol			Match tolerance.
* \param	mNod			Array for matched nodes.
*/
int		WlzCMeshMatchNNod2D(WlzCMesh2D *mesh, int nNod,
				    WlzDVertex2 *nPos, double tol,
				    WlzCMeshNod2D **mNod)
{
  int		idN,
  		cnt = 0;

  for(idN = 0; idN < nNod; ++idN)
  {
    cnt += (*(mNod + idN) =
            WlzCMeshMatchNod2D(mesh, *(nPos + idN), tol)) != NULL;
  }
  return(cnt);
}

/*!
* \return	Number of matched nodes.
* \ingroup	WlzMesh
* \brief	Locates the nodes matching the given vertex positions.
*		The matched nodes are the mesh nodes which have the
*		same positions (within given tolerance distance) of
*		the given vertices.
* \param	mesh			The mesh.
* \param	nNod			Number of node positions to match.
* \param	nPos			Node positions.
* \param	tol			Match tolerance.
* \param	mNod			Array for matched nodes.
*/
int		WlzCMeshMatchNNod2D5(WlzCMesh2D5 *mesh, int nNod,
				     WlzDVertex3 *nPos, double tol,
				     WlzCMeshNod2D5 **mNod)
{
  int		idN,
  		cnt = 0;

  for(idN = 0; idN < nNod; ++idN)
  {
    cnt += (*(mNod + idN) =
            WlzCMeshMatchNod2D5(mesh, *(nPos + idN), tol)) != NULL;
  }
  return(cnt);
}

/*!
* \return	Number of matched nodes.
* \ingroup	WlzMesh
* \brief	Locates the nodes matching the given vertex positions.
*		The matched nodes are the mesh nodes which have the
*		same positions (within given tolerance distance) of
*		the given vertices.
* \param	mesh			The mesh.
* \param	nNod			Number of node positions to match.
* \param	nPos			Node positions.
* \param	tol			Match tolerance.
* \param	mNod			Array for matched nodes.
*/
int		WlzCMeshMatchNNod3D(WlzCMesh3D *mesh, int nNod,
				    WlzDVertex3 *nPos, double tol,
				    WlzCMeshNod3D **mNod)
{
  int		idN,
  		cnt = 0;

  for(idN = 0; idN < nNod; ++idN)
  {
    cnt += (*(mNod + idN) =
            WlzCMeshMatchNod3D(mesh, *(nPos + idN), tol)) != NULL;
  }
  return(cnt);
}

/*!
* \return	Number of matched nodes.
* \ingroup	WlzMesh
* \brief	Locates the nodes matching the given vertex positions.
*		The matched nodes are the mesh nodes which have the
*		same positions (within given tolerance distance) of
*		the given vertices.
* \param	mesh			The mesh.
* \param	nNod			Number of node positions to match.
* \param	nPos			Node positions.
* \param	tol			Match tolerance.
* \param	mIdx			For indices of the matched nodes.
*/
int		WlzCMeshMatchNNodIdx2D(WlzCMesh2D *mesh, int nNod,
				       WlzDVertex2 *nPos, double tol,
				       int *mIdx)
{
  int		idN,
  		cnt = 0;
  WlzCMeshNod2D *nod;

  for(idN = 0; idN < nNod; ++idN)
  {
    nod = WlzCMeshMatchNod2D(mesh, *(nPos + idN), tol);
    if((nod != NULL) && (nod->idx >= 0))
    {
      *(mIdx + idN) = nod->idx;
      ++cnt;
    }
  }
  return(cnt);
}

/*!
* \return	Number of matched nodes.
* \ingroup	WlzMesh
* \brief	Locates the nodes matching the given vertex positions.
*		The matched nodes are the mesh nodes which have the
*		same positions (within WLZ_MESH_TOLERANCE distance) of
*		the given vertices.
* \param	mesh			The mesh.
* \param	nNod			Number of node positions to match.
* \param	nPos			Node positions.
* \param	tol			Match tolerance.
* \param	mIdx			For indices of the matched nodes.
*/
int		WlzCMeshMatchNNodIdx2D5(WlzCMesh2D5 *mesh, int nNod,
				        WlzDVertex3 *nPos, double tol,
					int *mIdx)
{
  int		idN,
  		cnt = 0;
  WlzCMeshNod2D5 *nod;

  for(idN = 0; idN < nNod; ++idN)
  {
    nod = WlzCMeshMatchNod2D5(mesh, *(nPos + idN), tol);
    if((nod != NULL) && (nod->idx >= 0))
    {
      *(mIdx + idN) = nod->idx;
      ++cnt;
    }
  }
  return(cnt);
}

/*!
* \return	Number of matched nodes.
* \ingroup	WlzMesh
* \brief	Locates the nodes matching the given vertex positions.
*		The matched nodes are the mesh nodes which have the
*		same positions (within WLZ_MESH_TOLERANCE distance) of
*		the given vertices.
* \param	mesh			The mesh.
* \param	nNod			Number of node positions to match.
* \param	nPos			Node positions.
* \param	tol			Match tolerance.
* \param	mIdx			For indices of the matched nodes.
*/
int		WlzCMeshMatchNNodIdx3D(WlzCMesh3D *mesh, int nNod,
				       WlzDVertex3 *nPos, double tol,
				       int *mIdx)
{
  int		idN,
  		cnt = 0;
  WlzCMeshNod3D *nod;

  for(idN = 0; idN < nNod; ++idN)
  {
    nod = WlzCMeshMatchNod3D(mesh, *(nPos + idN), tol);
    if((nod != NULL) && (nod->idx >= 0))
    {
      *(mIdx + idN) = nod->idx;
      ++cnt;
    }
  }
  return(cnt);
}

/*!
* \return       Element index or negative value if there is no enclosing
*               element.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position.
*
*		If a valid last element index is given then a search is
*		made for the enclosing element both within this element
*		and then, if not found, within it's immediate edge
*		neighbours.
*		If this simple 'walk search' fails to locate the enclosing
*		element a 'jump search' is used in which the grid cells
*		of the conforming mesh are searched.
* \param        mesh			The mesh.
* \param        lastElmIdx		Last element index to help efficient
* 					location. If negative this is ignored.
* \param        pX			Column coordinate of position.
* \param        pY			Line coordinate of position.
* \param        pZ			Plane coordinate of position (ignored
*                                       for 2D).
* \param	exhaustive		If non zero every element is the mesh
* 					is checked to see if the position is
* 					contained within it. This is very
* 					slow and is probably only useful for
* 					debuging.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
int             WlzCMeshElmEnclosingPos(WlzCMeshP mesh,
                                        int lastElmIdx,
                                        double pX, double pY, double pZ,
					int exhaustive, int *dstCloseNod)
{
  int           elmIdx = -1;

  switch(mesh.m2->type)
  {
    case WLZ_CMESH_2D:
      elmIdx = WlzCMeshElmEnclosingPos2D(mesh.m2, lastElmIdx, pX, pY,
					 exhaustive, dstCloseNod);
      break;
    case WLZ_CMESH_3D:
      elmIdx = WlzCMeshElmEnclosingPos3D(mesh.m3, lastElmIdx, pX, pY, pZ,
					 exhaustive, dstCloseNod);
      break;
  }
  return(elmIdx);
}

/*!
* \return       Element index or negative value if there is no enclosing
*               element.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position.
*
*		If a valid last element index is given then a search is
*		made for the enclosing element both within this element
*		and then, if not found, within it's immediate edge
*		neighbours.
*		If this simple 'walk search' fails to locate the enclosing
*		element a 'jump search' is used in which the grid cells
*		of the conforming mesh are searched.
*		For jump search to work coreectly the maximum edge
*		length in th emesh must be valid.
* \param        mesh			The mesh.
* \param        lastElmIdx		Last element index to help efficient
* 					location. If negative this is ignored.
* \param        pX			Column coordinate of position.
* \param        pY			Line coordinate of position.
* \param	exhaustive		If non zero every element is the mesh
* 					is checked to see if the position is
* 					contained within it. This is very
* 					slow and is probably only useful for
* 					debuging.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
int             WlzCMeshElmEnclosingPos2D(WlzCMesh2D *mesh,
                                        int lastElmIdx,
                                        double pX, double pY,
					int exhaustive, int *dstCloseNod)
{
  WlzDVertex2	gPos;
  int           elmIdx = -1;

  gPos.vtX = pX;
  gPos.vtY = pY;
  if(exhaustive)
  {
    elmIdx = WlzCMeshElmExhaustivePos2D(mesh, gPos, dstCloseNod);
  }
  else
  {
    if(lastElmIdx >= 0)
    {
      elmIdx = WlzCMeshElmWalkPos2D(mesh, lastElmIdx, gPos);
    }
    if(elmIdx < 0)
    {
      elmIdx = WlzCMeshElmJumpPos2D(mesh, gPos, dstCloseNod);
    }
  }
  return(elmIdx);
}

/*!
* \return       Element index or negative value if there is no enclosing
*               element.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position.
*
*		If a valid last element index is given then a search is
*		made for the enclosing element both within this element
*		and then, if not found, within it's immediate edge
*		neighbours.
*		If this simple 'walk search' fails to locate the enclosing
*		element a 'jump search' is used in which the grid cells
*		of the conforming mesh are searched.
*		For jump search to work coreectly the maximum edge
*		length in th emesh must be valid.
* \param        mesh			The mesh.
* \param        dummyLastElmIdx		Last element index used to help
* 					efficient location for 2D and 3D,
* 					but ignored by this function.
* \param        pX			Column coordinate of position.
* \param        pY			Line coordinate of position.
* \param        pZ			Plane coordinate of position.
* \param	exhaustive		If non zero every element is the mesh
* 					is checked to see if the position is
* 					contained within it. This is very
* 					slow and is probably only useful for
* 					debuging.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
int             WlzCMeshElmEnclosingPos2D5(WlzCMesh2D5 *mesh,
                                        int dummyLastElmIdx,
                                        double pX, double pY, double pZ,
					int exhaustive, int *dstCloseNod)
{
  WlzDVertex3	gPos;
  int           elmIdx;

  gPos.vtX = pX;
  gPos.vtY = pY;
  gPos.vtZ = pZ;
  elmIdx = (exhaustive)? WlzCMeshElmExhaustivePos2D5(mesh, gPos, dstCloseNod)
                       : WlzCMeshElmJumpPos2D5(mesh, gPos, dstCloseNod);
  return(elmIdx);
}

/*!
* \return       Element index or negative value if there is no enclosing
*               element.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position.
*
*		If a valid last element index is given then a search is
*		made for the enclosing element both within this element
*		and then, if not found, within it's immediate edge
*		neighbours.
*		If this simple 'walk search' fails to locate the enclosing
*		element a 'jump search' is used in which the grid cells
*		of the conforming mesh are searched.
*		For jump search to work coreectly the maximum edge
*		length in th emesh must be valid.
* \param        mesh			The mesh.
* \param        lastElmIdx		Last element index to help efficient
* 					location. If negative this is ignored.
* \param        pX			Column coordinate of position.
* \param        pY			Line coordinate of position.
* \param        pZ			Plane coordinate of position.
* \param	exhaustive		If non zero every element is the mesh
* 					is checked to see if the position is
* 					contained within it. This is very
* 					slow and is probably only useful for
* 					debuging.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
int             WlzCMeshElmEnclosingPos3D(WlzCMesh3D *mesh,
                                        int lastElmIdx,
                                        double pX, double pY, double pZ,
					int exhaustive, int *dstCloseNod)
{
  WlzDVertex3	gPos;
  int           elmIdx = -1;

  gPos.vtX = pX;
  gPos.vtY = pY;
  gPos.vtZ = pZ;
  if(exhaustive)
  {
    elmIdx = WlzCMeshElmExhaustivePos3D(mesh, gPos, dstCloseNod);
  }
  else
  {
    if(lastElmIdx >= 0)
    {
      elmIdx = WlzCMeshElmWalkPos3D(mesh, lastElmIdx, gPos);
    }
    if(elmIdx < 0)
    {
      elmIdx = WlzCMeshElmJumpPos3D(mesh, gPos, dstCloseNod);
    }
  }
  return(elmIdx);
}

/*!
* \return       Element index or negative value if there is no enclosing
*               or close element.
* \ingroup	WlzMesh
* \brief	Locates the element in the conforming mesh which encloses
*		or is closest to the vertex with the given position.
*		The computed position will be inside the mesh by a
*		distance of more than WLZ_MESH_TOLERANCE provided that
*		an enclosing or close element is found.
* \param        mesh			The mesh.
* \param        dstPos			Destination pointer for found
* 					position within element. Not set if
* 					element returned is invalid.
* \param        pos			Given vertex position.
* \param	dMax			Maximum distance to search for a
* 					close element.
*/
int		WlzCMeshElmClosestPosIn(WlzCMeshP mesh,
					WlzVertexP dstPos, WlzVertex pos,
					double dMax)
{
  int           elmIdx = -1;

  switch(mesh.m2->type)
  {
    case WLZ_CMESH_2D:
      elmIdx = WlzCMeshElmClosestPosIn2D(mesh.m2, dstPos.d2, pos.d2, dMax);
      break;
    case WLZ_CMESH_2D5:
      elmIdx = WlzCMeshElmClosestPosIn2D5(mesh.m2d5, dstPos.d3, pos.d3, dMax);
      break;
    case WLZ_CMESH_3D:
      elmIdx = WlzCMeshElmClosestPosIn3D(mesh.m3, dstPos.d3, pos.d3, dMax);
      break;
  }
  return(elmIdx);
}

/*!
* \return       Element index or negative value if there is no close by
* 		enclosing element found.
* \ingroup	WlzMesh
* \brief	Locates the element in the conforming mesh which encloses
*		or is closest to the given vertex position, provided that
*		the distance is no more than the maximum distance. The
*		position within the element will always be more than
*		WLZ_MESH_TOLERANCE from the mesh boundary provided that
*		an enclosing or close element is found.
*
* \param        mesh			The mesh.
* \param        dstPos			Destination pointer for found
* 					position within element. Not set if
* 					element returned is invalid. May be
* 					NULL.
* \param        pos			Given vertex position.
* \param	dMax			Maximum distance for found position
* 					from given position.
*/
int		WlzCMeshElmClosestPosIn2D(WlzCMesh2D *mesh,
                                      WlzDVertex2 *dstPos, WlzDVertex2 pos,
				      double dMax)
{
  int		ring = 0,
  		maxRing,
		elmIdx = -1,
		spiralCnt = 0;
  double	d,
		dMaxSq,
		minDstSq = DBL_MAX;
  WlzIVertex2	idx,
  		idx0,
  		idx1;
  WlzDVertex2	minInPos;
  WlzCMeshElm2D *minElm = NULL;
  WlzCMeshCellElm2D *cElm;
  WlzCMeshCell2D *cell;

  dMaxSq = dMax * dMax;
  minInPos.vtX = minInPos.vtY = 0.0;
  if(mesh->res.nod.numEnt > 0)
  {
    /* First find element that either encloses or else is close to the
     * vertex with the given position. */
    idx1.vtX = idx1.vtY = 0;
    maxRing = 1 + 
              (int )ceil(1.5 * dMax / mesh->cGrid.cellSz); /* 1.5 >~ sqrt(2) */
    /* Find grid cell containing (or close to) the vertex. */
    idx0 = WlzCMeshCellIdxVtx2D(mesh, pos);
    do /* For each grid cell. */
    {
      d = minDstSq;
      idx.vtX = idx0.vtX + idx1.vtX;
#ifdef WLZ_FAST_CODE
      if((unsigned int )(idx.vtX) <= (unsigned int )(mesh->cGrid.nCells.vtX))
#else
      if((idx.vtX >= 0) && (idx.vtX < mesh->cGrid.nCells.vtX))
#endif
      {
        idx.vtY = idx0.vtY + idx1.vtY;
#ifdef WLZ_FAST_CODE
        if((unsigned int )(idx.vtY) <= (unsigned int )(mesh->cGrid.nCells.vtY))
#else
        if((idx.vtY >= 0) && (idx.vtY < mesh->cGrid.nCells.vtY))
#endif
	{
	  /* For each element that intersects this cell, find the minimum
	   * distance from the vertex to this element and so search for
	   * the element with the minimum distance from the vertex. */
	  cell = *(mesh->cGrid.cells + idx.vtY) + idx.vtX;
	  cElm = cell->cElm;
	  while(cElm && (minDstSq > WLZ_MESH_TOLERANCE_SQ))
	  {
	    WlzDVertex2	inPos;
	    WlzCMeshElm2D *elm;

	    if((elm = cElm->elm) != NULL)
	    {
	      WlzCMeshNod2D *nod[3];

	      if((minElm == NULL) && (maxRing > ring + 1))
	      {
		maxRing = ring + 1;
	      }
	      /* Square of distance but -ve if inside triangle, 0 if on it
	       * and +ve outside of the triangle. */
	      nod[0] = WLZ_CMESH_ELM2D_GET_NODE_0(elm);
	      nod[1] = WLZ_CMESH_ELM2D_GET_NODE_1(elm);
	      nod[2] = WLZ_CMESH_ELM2D_GET_NODE_2(elm);
	      d = WlzGeomTriangleVtxDistSq2D(&inPos, NULL, pos, nod[0]->pos,
					     nod[1]->pos, nod[2]->pos);
	      if(d < minDstSq)
	      {
		minDstSq = d;
		minElm = cElm->elm;
		minInPos = inPos;
	      }
	    }
	    cElm = cElm->next;
	  }
	}
      }
      /* Spiral out from the initial grid cell. */
      spiralCnt = WlzGeomItrSpiral2I(spiralCnt, &(idx1.vtX), &(idx1.vtY));
      ring = WlzGeomItrSpiralRing(spiralCnt);
      /* Stop spiraling out when the ring after the first ontain an element
       * has been searched or an element containing the vertex has been
       * found. */
    } while((minDstSq > WLZ_MESH_TOLERANCE_SQ) && (ring < maxRing));
    if(minDstSq < dMaxSq)
    {
      /* Have found an element which either encloses the vertex or else
       * is the closest and within the given maximum distance (dMax).
       * Now find position within mesh that is at least tol2 from the
       * element boundary. */
      elmIdx = minElm->idx;
      if(dstPos)
      {
	if(minDstSq > -(WLZ_MESH_TOLERANCE))
	{
	  WlzDVertex2	c,
	  		e;
	  WlzCMeshNod2D *nod[3];

	  nod[0] = WLZ_CMESH_ELM2D_GET_NODE_0(minElm);
	  nod[1] = WLZ_CMESH_ELM2D_GET_NODE_1(minElm);
	  nod[2] = WLZ_CMESH_ELM2D_GET_NODE_2(minElm);
	  c = WlzGeomTriangleCen2D(nod[0]->pos, nod[1]->pos, nod[2]->pos);
	  WLZ_VTX_2_SUB(e, c, minInPos);
	  WLZ_VTX_2_FABS(e, e);
	  WLZ_VTX_2_SCALE(e, e, 10.0 * WLZ_MESH_TOLERANCE);
	  pos.vtX = WlzCMeshAddTolToBndAndClamp(minInPos.vtX, c.vtX, e.vtX);
	  pos.vtY = WlzCMeshAddTolToBndAndClamp(minInPos.vtY, c.vtY, e.vtY);
	}
        *dstPos = pos;
      }
    }
  }
  return(elmIdx);
}

int		WlzCMeshElmClosestPosIn2D5(WlzCMesh2D5 *mesh,
					 WlzDVertex3 *dstPos, WlzDVertex3 pos,
					 double dMax)
{
  int		elmIdx = -1;

  /* TODO */
  if(dstPos)
  {
    *dstPos = pos;
  }
  return(elmIdx);
}

/*!
* \return       Element index or negative value if there is no close by
* 		enclosing element found.
* \ingroup	WlzMesh
* \brief	Locates the element in the conforming mesh which encloses
*		or is closest to the given vertex position, provided that
*		the distance is no more than the maximum distance. The
*		position within the element will always be more than
*		WLZ_MESH_TOLERANCE from the mesh boundary provided that
*		an enclosing or close element is found.
*
* \param        mesh			The mesh.
* \param        dstPos			Destination pointer for found
* 					position within element. Not set if
* 					element returned is invalid.
* \param        pos			Given vertex position.
* \param	dMax			Maximum distance for found position
* 					from given position.
*/
int		WlzCMeshElmClosestPosIn3D(WlzCMesh3D *mesh,
                                      WlzDVertex3 *dstPos, WlzDVertex3 pos,
				      double dMax)
{
  int		ring = 0,
  		maxRing,
		elmIdx = -1,
		spiralCnt = 0;
  double	d,
		dMaxSq,
		minDstSq = DBL_MAX;
  WlzIVertex3	idx,
  		idx0,
  		idx1;
  WlzDVertex3	cPos,
  		minInPos;
  WlzCMeshElm3D *minElm = NULL;
  WlzCMeshCellElm3D *cElm;
  WlzCMeshCell3D *cell;

  cPos = pos;
  dMaxSq = dMax * dMax;
  minInPos.vtX = minInPos.vtY = minInPos.vtZ = 0.0;
  if(mesh->res.nod.numEnt > 0)
  {
    /* First find element that either encloses or else is close to the
     * vertex with the given position. */
    idx1.vtX = idx1.vtY = idx1.vtZ = 0;
    maxRing = 1 + 
              (int )ceil(1.5 * dMax / mesh->cGrid.cellSz); /* 1.5 >~ cbrt(3) */
    /* Find grid cell containing (or close to) the vertex. */
    idx0 = WlzCMeshCellIdxVtx3D(mesh, pos);
    do /* For each grid cell. */
    {
      d = minDstSq;
      idx.vtX = idx0.vtX + idx1.vtX;
#ifdef WLZ_FAST_CODE
      if((unsigned int )(idx.vtX) < (unsigned int )(mesh->cGrid.nCells.vtX))
#else
      if((idx.vtX >= 0) && (idx.vtX < mesh->cGrid.nCells.vtX))
#endif
      {
	idx.vtY = idx0.vtY + idx1.vtY;
#ifdef WLZ_FAST_CODE
	if((unsigned int )(idx.vtY) < (unsigned int )(mesh->cGrid.nCells.vtY))
#else
        if((idx.vtY >= 0) && (idx.vtY < mesh->cGrid.nCells.vtY))
#endif
	{
          idx.vtZ = idx0.vtZ + idx1.vtZ;
#ifdef WLZ_FAST_CODE
	  if((unsigned int )(idx.vtZ) < (unsigned int )(mesh->cGrid.nCells.vtZ))
#else
          if((idx.vtZ >= 0) && (idx.vtZ < mesh->cGrid.nCells.vtZ))
#endif
	  {
	    /* For each element that intersects this cell, find the minimum
	     * distance from the vertex to this element and so search for
	     * the element with the minimum distance from the vertex. */
	    cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
	    cElm = cell->cElm;
	    while(cElm && (minDstSq > WLZ_MESH_TOLERANCE_SQ))
	    {
	      WlzDVertex3	inPos;
	      WlzCMeshElm3D *elm;

	      if((elm = cElm->elm) != NULL)
	      {
		WlzCMeshNod3D *nod[4];

		if((minElm == NULL) && (maxRing > ring + 1))
		{
		  maxRing = ring + 1;
		}
		/* Square of distance but -ve if inside tetrahedron, 0 if on it
		 * and +ve outside of the tetrahedron. */
		nod[0] = WLZ_CMESH_ELM3D_GET_NODE_0(elm);
		nod[1] = WLZ_CMESH_ELM3D_GET_NODE_1(elm);
		nod[2] = WLZ_CMESH_ELM3D_GET_NODE_2(elm);
		nod[3] = WLZ_CMESH_ELM3D_GET_NODE_3(elm);
		d = WlzGeomTetrahedronVtxDistSq3D(&inPos, NULL, pos,
						  nod[0]->pos, nod[1]->pos,
						  nod[2]->pos, nod[3]->pos);
		if(d < minDstSq)
		{
		  minDstSq = d;
		  minElm = cElm->elm;
		  minInPos = inPos;
		}
	      }
	      cElm = cElm->next;
	    }
	  }
        }
      }
      /* Spiral out from the initial grid cell. */
      spiralCnt = WlzGeomItrSpiral3I(spiralCnt,
                                     &(idx1.vtX), &(idx1.vtY), &(idx1.vtZ));
      ring = WlzGeomItrSpiralRing(spiralCnt);
      /* Stop spiraling out when the ring after the first ontain an element
       * has been searched or an element containing the vertex has been
       * found. */
    } while((minDstSq > WLZ_MESH_TOLERANCE_SQ) && (ring < maxRing));
    if(minDstSq < dMaxSq)
    {
      /* Have found an element which either encloses the vertex or else
       * is the closest and within the given maximum distance (dMax).
       * Now find position within mesh that is inside the element. */
      elmIdx = minElm->idx;
      if(dstPos)
      {
	if(minDstSq > -(WLZ_MESH_TOLERANCE))
	{
	  WlzDVertex3	c,
	  		e;
	  WlzCMeshNod3D *nod[4];

	  nod[0] = WLZ_CMESH_ELM3D_GET_NODE_0(minElm);
	  nod[1] = WLZ_CMESH_ELM3D_GET_NODE_1(minElm);
	  nod[2] = WLZ_CMESH_ELM3D_GET_NODE_2(minElm);
	  nod[3] = WLZ_CMESH_ELM3D_GET_NODE_3(minElm);
	  c = WlzGeomTetrahedronCen3D(nod[0]->pos, nod[1]->pos,
	                              nod[2]->pos, nod[3]->pos);
	  WLZ_VTX_3_SUB(e, c, minInPos);
	  WLZ_VTX_3_SCALE(e, e, 10.0 * WLZ_MESH_TOLERANCE);
	  WLZ_VTX_3_ADD(cPos, minInPos, e);
	}
        *dstPos = cPos;
      }
    }
  }
#ifdef WLZ_DEBUG_WLZCMESHELMCLOSESTPOSIN3D
  if(minElm)
  {
    WlzDVertex3	  cen;
    WlzCMeshNod3D *nod[4];

    nod[0] = WLZ_CMESH_ELM3D_GET_NODE_0(minElm);
    nod[1] = WLZ_CMESH_ELM3D_GET_NODE_1(minElm);
    nod[2] = WLZ_CMESH_ELM3D_GET_NODE_2(minElm);
    nod[3] = WLZ_CMESH_ELM3D_GET_NODE_3(minElm);
    cen = WlzGeomTetrahedronCen3D(nod[0]->pos, nod[1]->pos,
				  nod[2]->pos, nod[3]->pos);
    (void )fprintf(stderr, "# vtk DataFile Version 1.0\n"
                           "WlzCMeshElmClosestPosIn3D() debug output, elm %d\n"
			   "ASCII\n"
			   "DATASET POLYDATA\n"
			   "POINTS 7 float\n"
                           "%g %g %g\n"
			   "%g %g %g\n"
			   "%g %g %g\n"
			   "%g %g %g\n"
			   "%g %g %g\n"
			   "%g %g %g\n"
			   "%g %g %g\n"
			   "POLYGONS 5 20\n"
			   "3 0 1 2\n"
			   "3 0 1 3\n"
			   "3 1 2 3\n"
			   "3 2 0 3\n"
			   "3 4 5 6\n",
			   elmIdx,
			   nod[0]->pos.vtX, nod[0]->pos.vtY, nod[0]->pos.vtZ,
			   nod[1]->pos.vtX, nod[1]->pos.vtY, nod[1]->pos.vtZ,
			   nod[2]->pos.vtX, nod[2]->pos.vtY, nod[2]->pos.vtZ,
			   nod[3]->pos.vtX, nod[3]->pos.vtY, nod[3]->pos.vtZ,
			   pos.vtX, pos.vtY, pos.vtZ,
			   cPos.vtX, cPos.vtY, cPos.vtZ,
			   cen.vtX, cen.vtY, cen.vtZ);
  }
#endif
  return(elmIdx);
}

/*!
* \return	Clamped displaced boundary coordinate.
* \ingroup	WlzMesh
* \brief	Given a boundary coordinate, a centre coordinate and a
* 		small displacement. The boundary value is displace toward
* 		the centre coordinate by the small displacement unless it
* 		takes it past the centre value.
* \param	b			Boundary coordinate.
* \param	c			Centre coordinate.
* \param	t			Small displacement.
*/
static double	WlzCMeshAddTolToBndAndClamp(double b, double c, double t)
{
  double 	d;

  d = c - b;
  if(d > DBL_EPSILON)
  {
    d = b + t;
    b = (d > c)? c: d;
  }
  else if(d < DBL_EPSILON)
  {
    d = b - t;
    b = (d < c)? c: d;
  }
  return(b);
}


/*!
* \return	Element index or negative value if no enclosing element found.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position by testing the given element and it's
*		immediate edge neighbours.
* \param	mesh			The mesh.
* \param	elmIdx			Index of first element to test.
* \param	gPos			Test position.
*/
static int	WlzCMeshElmWalkPos2D(WlzCMesh2D *mesh, int elmIdx,
				     WlzDVertex2 gPos)
{
  int		idE;
  WlzCMeshElm2D	*elm0,
  		*elm1;

  if((elmIdx >= 0) && (elmIdx < mesh->res.elm.maxEnt))
  {
    elm0 = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, elmIdx);
    if(WlzCMeshElmEnclosesPos2D(elm0, gPos) == 0)
    {
      elmIdx = -1;
      for(idE = 0; idE < 3; ++idE)
      {
	if(elm0->edu[idE].opp)
	{
	  elm1 = elm0->edu[idE].opp->elm;
	  if(WlzCMeshElmEnclosesPos2D(elm1, gPos) != 0)
	  {
	    elmIdx = elm1->idx;
	    break;
	  }
	}
      }
    }
  }
  return(elmIdx);
}

/*!
* \return	Index of the enclosing element or < 0 if no enclosing
*		element is found.
* \ingroup	WlzMesh
* \brief	Performs an exhaustive search for the conforming mesh
* 		element which encloses the given position by examining
* 		all elements in the mesh or all elements in the mesh
* 		until the enclosing element is found. This function is
* 		very slow and is probably only useful for debuging.
* \param	mesh			The conforming  mesh.
* \param	gPos			Given position.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
static int	WlzCMeshElmExhaustivePos2D(WlzCMesh2D *mesh, WlzDVertex2 gPos,
				           int *dstCloseNod)
{
  int		idx,
  		elmIdx = -1;
  double	dstSq,
  		minDstSq;
  WlzDVertex2	del;
  WlzCMeshElm2D *elm;
  WlzCMeshNod2D *nod;

  for(idx = 0; idx < mesh->res.elm.maxEnt; ++idx)
  {
    elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idx);
    if(elm->idx >= 0)
    {
      if(WlzCMeshElmEnclosesPos2D(elm, gPos) != 0)
      {
        elmIdx = elm->idx;
	break;
      }
    }
  }
  if(dstCloseNod)
  {
    *dstCloseNod = -1;
    minDstSq = DBL_MAX;
    for(idx = 0; idx < mesh->res.nod.maxEnt; ++idx)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idx);
      if(nod->idx >= 0)
      {
        WLZ_VTX_2_SUB(del, gPos, nod->pos);
        dstSq = WLZ_VTX_2_SQRLEN(del);
	if(dstSq < minDstSq)
	{
	  minDstSq = dstSq;
	  *dstCloseNod = nod->idx;
	}
      }
    }
  }
  return(elmIdx);
}

/*!
* \return	Index of the enclosing element or < 0 if no enclosing
*		element is found.
* \ingroup	WlzMesh
* \brief	Performs an exhaustive search for the conforming mesh
* 		element which encloses the given position by examining
* 		all elements in the mesh or all elements in the mesh
* 		until the enclosing element is found. This function is
* 		very slow and is probably only useful for debuging.
* \param	mesh			The conforming  mesh.
* \param	gPos			Given position.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
static int	WlzCMeshElmExhaustivePos2D5(WlzCMesh2D5 *mesh, WlzDVertex3 gPos,
				            int *dstCloseNod)
{
  int		idx,
  		elmIdx = -1;
  double	dstSq,
  		minDstSq;
  WlzDVertex3	del;
  WlzCMeshElm2D5 *elm;
  WlzCMeshNod2D5 *nod;

  for(idx = 0; idx < mesh->res.elm.maxEnt; ++idx)
  {
    elm = (WlzCMeshElm2D5 *)AlcVectorItemGet(mesh->res.elm.vec, idx);
    if(elm->idx >= 0)
    {
      if(WlzCMeshElmEnclosesPos2D5(elm, gPos) != 0)
      {
        elmIdx = elm->idx;
	break;
      }
    }
  }
  if(dstCloseNod)
  {
    *dstCloseNod = -1;
    minDstSq = DBL_MAX;
    for(idx = 0; idx < mesh->res.nod.maxEnt; ++idx)
    {
      nod = (WlzCMeshNod2D5 *)AlcVectorItemGet(mesh->res.nod.vec, idx);
      if(nod->idx >= 0)
      {
        WLZ_VTX_3_SUB(del, gPos, nod->pos);
        dstSq = WLZ_VTX_3_SQRLEN(del);
	if(dstSq < minDstSq)
	{
	  minDstSq = dstSq;
	  *dstCloseNod = nod->idx;
	}
      }
    }
  }
  return(elmIdx);
}

/*!
* \return	Index of the enclosing element or < 0 if no enclosing
*		element is found.
* \ingroup	WlzMesh
* \brief	Performs an exhaustive search for the conforming mesh
* 		element which encloses the given position by examining
* 		all elements in the mesh or all elements in the mesh
* 		until the enclosing element is found. This function is
* 		very slow and is probably only useful for debuging.
* \param	mesh			The conforming  mesh.
* \param	gPos			Given position.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
*/
static int	WlzCMeshElmExhaustivePos3D(WlzCMesh3D *mesh, WlzDVertex3 gPos,
				           int *dstCloseNod)
{
  int		idx,
  		elmIdx = -1;
  double	dstSq,
  		minDstSq;
  WlzDVertex3	del;
  WlzCMeshElm3D *elm;
  WlzCMeshNod3D *nod;

  for(idx = 0; idx < mesh->res.elm.maxEnt; ++idx)
  {
    elm = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, idx);
    if(elm->idx >= 0)
    {
      if(WlzCMeshElmEnclosesPos3D(elm, gPos) != 0)
      {
        elmIdx = elm->idx;
	break;
      }
    }
  }
  if(dstCloseNod)
  {
    *dstCloseNod = -1;
    minDstSq = DBL_MAX;
    for(idx = 0; idx < mesh->res.nod.maxEnt; ++idx)
    {
      nod = (WlzCMeshNod3D *)AlcVectorItemGet(mesh->res.nod.vec, idx);
      if(nod->idx >= 0)
      {
        WLZ_VTX_3_SUB(del, gPos, nod->pos);
        dstSq = WLZ_VTX_3_SQRLEN(del);
	if(dstSq < minDstSq)
	{
	  minDstSq = dstSq;
	  *dstCloseNod = nod->idx;
	}
      }
    }
  }
  return(elmIdx);
}


/*!
* \return	Element index or negative value if no enclosing element found.
* \ingroup	WlzMesh
* \brief	Locates the element of the conforming mesh which encloses
*		the given position by testing the given element and it's
*		immediate face neighbours.
* \param	mesh			The mesh.
* \param	elmIdx			Index of first element to test.
* \param	gPos			Test position.
*/
static int	WlzCMeshElmWalkPos3D(WlzCMesh3D *mesh, int elmIdx,
				     WlzDVertex3 gPos)
{
  int		idF;
  WlzCMeshElm3D	*elm0,
  		*elm1;

  if((elmIdx >= 0) && (elmIdx < mesh->res.elm.maxEnt))
  {
    elm0 = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, elmIdx);
    if(WlzCMeshElmEnclosesPos3D(elm0, gPos) == 0)
    {
      elmIdx = -1;
      for(idF = 0; idF < 4; ++idF)
      {
	if(elm0->face[idF].opp)
	{
	  elm1 = elm0->face[idF].opp->elm;
	  if(WlzCMeshElmEnclosesPos3D(elm1, gPos) != 0)
	  {
	    elmIdx = elm1->idx;
	    break;
	  }
	}
      }
    }
  }
  return(elmIdx);
}

/*!
* \return	Index of the enclosing element or < 0 if no enclosing
*		element is found.
* \ingroup	WlzMesh
* \brief	Finds which cell or small group of cells (if degenerate)
* 		the given position lies within. Then searches the cell
* 		for the first element which encloses the position.
* 		This element may not be unique if the position is
* 		coincident with a node or and edge of the mesh.
* \param	mesh			The conforming  mesh.
* \param	pos			Given position.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
* 					The function may be much faster if
* 					dstCloseNod is NULL.
*/
static int	WlzCMeshElmJumpPos2D(WlzCMesh2D *mesh, WlzDVertex2 pos,
				     int *dstCloseNod)
{
  int		elmIdx = -1;
  double	delta;
  WlzDVertex2	pos0;
  WlzIVertex2	idx,
  		idxMin,
		idxMax;
  WlzCMeshCell2D *cell;
  WlzCMeshCellElm2D *cElm;
  const double	eps = 0.001;

  /* Search within a range of cells because the vertex may be on the
   * edge of a cell. */
  delta = eps * mesh->cGrid.cellSz;
  pos0.vtX = pos.vtX - delta;
  pos0.vtY = pos.vtY - delta;
  idxMin = WlzCMeshCellIdxVtx2D(mesh, pos0);
  pos0.vtX = pos.vtX + delta;
  pos0.vtY = pos.vtY + delta;
  idxMax = WlzCMeshCellIdxVtx2D(mesh, pos0);
  for(idx.vtY = idxMin.vtY; idx.vtY <= idxMax.vtY; ++idx.vtY)
  {
    for(idx.vtX = idxMin.vtX; idx.vtX <= idxMax.vtX; ++idx.vtX)
    {
      cell = *(mesh->cGrid.cells + idx.vtY) + idx.vtX;
      cElm = cell->cElm;
      while(cElm)
      {
	if(WlzCMeshElmEnclosesPos2D(cElm->elm, pos))
	{
	  elmIdx = cElm->elm->idx;
	  goto FOUND;
	}
	cElm = cElm->next;
      }
    }
  }
FOUND:
  if(dstCloseNod)
  {
    *dstCloseNod = WlzCMeshClosestNod2D(mesh, pos);
  }
  return(elmIdx);
}

/*!
* \return	Index of the enclosing element or < 0 if no enclosing
*		element is found.
* \ingroup	WlzMesh
* \brief	Finds which cell or small group of cells (if degenerate)
* 		the given position lies within. Then searches the cell
* 		for the first element which encloses the position.
* 		This element may not be unique if the position is
* 		coincident with a node or and edge of the mesh.
* \param	mesh			The conforming  mesh.
* \param	pos			Given position.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
* 					The function may be much faster if
* 					dstCloseNod is NULL.
*/
static int	WlzCMeshElmJumpPos2D5(WlzCMesh2D5 *mesh, WlzDVertex3 pos,
				      int *dstCloseNod)
{
  int		elmIdx = -1;
  double	delta;
  WlzDVertex3	pos0;
  WlzIVertex3	idx,
  		idxMin,
		idxMax;
  WlzCMeshCell2D5 *cell;
  WlzCMeshCellElm2D5 *cElm;
  const double	eps = 0.001;

  /* Search within a range of cells because the vertex may be on the
   * edge of a cell. */
  delta = eps * mesh->cGrid.cellSz;
  pos0.vtX = pos.vtX - delta;
  pos0.vtY = pos.vtY - delta;
  pos0.vtZ = pos.vtZ - delta;
  idxMin = WlzCMeshCellIdxVtx2D5(mesh, pos0);
  pos0.vtX = pos.vtX + delta;
  pos0.vtY = pos.vtY + delta;
  pos0.vtZ = pos.vtZ + delta;
  idxMax = WlzCMeshCellIdxVtx2D5(mesh, pos0);
  for(idx.vtZ = idxMin.vtZ; idx.vtZ <= idxMax.vtZ; ++idx.vtZ)
  {
    for(idx.vtY = idxMin.vtY; idx.vtY <= idxMax.vtY; ++idx.vtY)
    {
      for(idx.vtX = idxMin.vtX; idx.vtX <= idxMax.vtX; ++idx.vtX)
      {
	cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
	cElm = cell->cElm;
	while(cElm)
	{
	  if(WlzCMeshElmEnclosesPos2D5(cElm->elm, pos))
	  {
	    elmIdx = cElm->elm->idx;
	    goto FOUND;
	  }
	  cElm = cElm->next;
	}
      }
    }
  }
FOUND:
  if(dstCloseNod)
  {
    *dstCloseNod = WlzCMeshClosestNod2D5(mesh, pos);
  }
  return(elmIdx);
}

/*!
* \return	Index of the enclosing element or < 0 if no enclosing
*		element is found.
* \ingroup	WlzMesh
* \brief	Finds which cell or small group of cells (if degenerate)
* 		the given position lies within. Then searches the cell
* 		for the first element which encloses the position.
* 		This element may not be unique if the position is
* 		coincident with a node or and edge of the mesh.
* \param	mesh			The conforming  mesh.
* \param	pos			Given position.
* \param	dstCloseNod		If non NULL, then the value is set
* 					to the index of the closest node
* 					to the given position.
* 					The function may be much faster if
* 					dstCloseNod is NULL.
*/
static int	WlzCMeshElmJumpPos3D(WlzCMesh3D *mesh, WlzDVertex3 pos,
				     int *dstCloseNod)
{
  int		elmIdx = -1;
  double	delta;
  WlzDVertex3	pos0;
  WlzIVertex3	idx,
  		idxMin,
		idxMax;
  WlzCMeshCell3D *cell;
  WlzCMeshCellElm3D *cElm;
  const double	eps = 0.001;

  /* Search within a range of cells because the vertex may be on the
   * edge of a cell. */
  delta = eps * mesh->cGrid.cellSz;
  pos0.vtX = pos.vtX - delta;
  pos0.vtY = pos.vtY - delta;
  pos0.vtZ = pos.vtZ - delta;
  idxMin = WlzCMeshCellIdxVtx3D(mesh, pos0);
  pos0.vtX = pos.vtX + delta;
  pos0.vtY = pos.vtY + delta;
  pos0.vtZ = pos.vtZ + delta;
  idxMax = WlzCMeshCellIdxVtx3D(mesh, pos0);
  for(idx.vtZ = idxMin.vtZ; idx.vtZ <= idxMax.vtZ; ++idx.vtZ)
  {
    for(idx.vtY = idxMin.vtY; idx.vtY <= idxMax.vtY; ++idx.vtY)
    {
      for(idx.vtX = idxMin.vtX; idx.vtX <= idxMax.vtX; ++idx.vtX)
      {
	cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
	cElm = cell->cElm;
	while(cElm)
	{
	  if(WlzCMeshElmEnclosesPos3D(cElm->elm, pos))
	  {
	    elmIdx = cElm->elm->idx;
	    goto FOUND;
	  }
	  cElm = cElm->next;
	}
      }
    }
  }
FOUND:
  if(dstCloseNod)
  {
    *dstCloseNod = WlzCMeshClosestNod3D(mesh, pos);
  }
  return(elmIdx);
}

/*!
* \return	Index of the closest node or a negative number on error.
* \ingroup	WlzMesh
* \brief	Finds the index of the closest node to the given position.
* 		
* 		Finds the index of the closest node to the given position
* 		by spiraling out from the cell containing the given
* 		position.
* \param	mesh			Given mesh.
* \param	pos			Given position.
*/
int		WlzCMeshClosestNod2D(WlzCMesh2D *mesh, WlzDVertex2 pos)
{
  int		ring = 0,
		firstRing = -1,
     		closeNod = -1,
		spiralCnt = 0;
  double	d0,
		minDstSq = DBL_MAX;
  WlzDVertex2	del;
  WlzIVertex2	idx,
  		idx0,
  		idx1;
  WlzCMeshNod2D	*nod;
  WlzCMeshCell2D *cell;

  if(mesh->res.nod.numEnt > 0)
  {
    idx1.vtX = idx1.vtY = 0;
    /* Find grid cell containing the given position. */
    idx0 = WlzCMeshCellIdxVtx2D(mesh, pos);
    do
    {
      WLZ_VTX_2_ADD(idx, idx0, idx1);
      if((idx.vtX >= 0) &&
	 (idx.vtY >= 0) &&
	 (idx.vtX < mesh->cGrid.nCells.vtX) &&
	 (idx.vtY < mesh->cGrid.nCells.vtY))
      {
	/* Look for closest node in this cell. */
	cell = *(mesh->cGrid.cells + idx.vtY) + idx.vtX;
	nod = cell->nod;
	while(nod)
	{
	  WLZ_VTX_2_SUB(del, pos, nod->pos);
	  d0 = WLZ_VTX_2_SQRLEN(del);
	  if(d0 < minDstSq)
	  {
	    closeNod = nod->idx;
	    minDstSq = d0;
	    if(firstRing < 0)
	    {
	      firstRing = ring;
	    }
	  }
	  nod = nod->next;
	}
      }
      /* Spiral out from the initial grid cell. */
      spiralCnt = WlzGeomItrSpiral2I(spiralCnt, &(idx1.vtX), &(idx1.vtY));
      ring = WlzGeomItrSpiralRing(spiralCnt);
      /* Stop spiraling out when the ring after the first in which a node
       * was found has been searched. */
    } while((firstRing < 0) || ((ring - firstRing) < 2));
  }
  return(closeNod);
}

/*!
* \return	Index of the closest node or a negative number on error.
* \ingroup	WlzMesh
* \brief	Finds the index of the closest node to the given position.
* 		
* 		Finds the index of the closest node to the given position
* 		by spiraling out from the cell containing the given
* 		position.
* \param	mesh			Given mesh.
* \param	p			Given position.
*/
int		WlzCMeshClosestNod2D5(WlzCMesh2D5 *mesh, WlzDVertex3 p)
{
  int		closeNod = -1,
		ring = 0,
		firstRing = -1,
		spiralCnt = 0;
  double	minDstSq = DBL_MAX;
  WlzIVertex3 	idx,
	      	idx0,
	      	idx1;
  WlzCMeshCellGrid2D5 *cGrid;
  const double	tol = WLZ_MESH_TOLERANCE;

  cGrid = &(mesh->cGrid);
  if(mesh->res.nod.numEnt > 0)
  {
    WlzDVertex3	gMin,
    		gMax;

    /* Check that the given test position is within the cell grid. */
    WLZ_VTX_3_SET(gMin,
                  mesh->bBox.xMin + tol,
		  mesh->bBox.yMin + tol,
		  mesh->bBox.zMin + tol);
    WLZ_VTX_3_SET(gMax,
                  mesh->bBox.xMin + (cGrid->nCells.vtX * cGrid->cellSz) - tol,
                  mesh->bBox.yMin + (cGrid->nCells.vtY * cGrid->cellSz) - tol,
                  mesh->bBox.zMin + (cGrid->nCells.vtZ * cGrid->cellSz) - tol);
    if((p.vtX > gMin.vtX) && (p.vtX < gMax.vtX) &&
       (p.vtY > gMin.vtY) && (p.vtY < gMax.vtY) &&
       (p.vtZ > gMin.vtZ) && (p.vtZ < gMax.vtZ))
    {
      /* Find grid cell containing the given position. */
      idx0 = WlzCMeshCellIdxVtx2D5(mesh, p);
    }
    else
    {
      /* Find the grid cell, the centroid of which is closest to the given
       * position. This is done by looking for the intersection of a ray
       * defined by kr + p with the axis aligned bounding box of the grid
       * of cells. */
      double	k,
      		l,
		lMSq = DBL_MAX;
      WlzDVertex3 d,
      		  q,
		  qM,
      		  r;

      qM.vtX = qM.vtY = qM.vtZ = 0.0;
      r.vtX = (0.5 * (gMin.vtX + gMax.vtX)) - p.vtX;
      r.vtY = (0.5 * (gMin.vtY + gMax.vtY)) - p.vtY;
      r.vtZ = (0.5 * (gMin.vtZ + gMax.vtZ)) - p.vtZ;
      /* Look for minimum distance intersection with the grid cells. */
      if(fabs(r.vtX) > tol)
      {
	/* Face x = gMin.vtX */
        k = (gMin.vtX - p.vtX) / r.vtX;
	WLZ_VTX_3_SET(q, gMin.vtX, p.vtY + (k * r.vtY), p.vtZ + (k * r.vtZ));
	if((q.vtY > gMin.vtY - tol) && (q.vtY < gMax.vtY + tol) &&
	   (q.vtZ > gMin.vtZ - tol) && (q.vtZ < gMax.vtZ + tol))
	{
	  WLZ_VTX_3_SUB(d, q, p);
	  lMSq = WLZ_VTX_3_SQRLEN(d);
	  qM = q;
	}
	/* Face x = gMax.vtX */
	k = (gMax.vtX - p.vtX) / r.vtX;
	WLZ_VTX_3_SET(q, gMax.vtX, p.vtY + (k * r.vtY), p.vtZ + (k * r.vtZ));
	if((q.vtY > gMin.vtY - tol) && (q.vtY < gMax.vtY + tol) &&
	   (q.vtZ > gMin.vtZ - tol) && (q.vtZ < gMax.vtZ + tol))
	{
	  WLZ_VTX_3_SUB(d, q, p);
	  l = WLZ_VTX_3_SQRLEN(d);
	  if(l < lMSq)
	  {
	    lMSq = l;
	    qM = q;
	  }
	}
      }
      if(fabs(r.vtY) > tol)
      {
	/* Face y = gMin.vtY */
        k = (gMin.vtY - p.vtY) / r.vtY;
	WLZ_VTX_3_SET(q, p.vtX + (k * r.vtX), gMin.vtY, p.vtZ + (k * r.vtZ));
	if((q.vtX > gMin.vtX - tol) && (q.vtX < gMax.vtX + tol) &&
	   (q.vtZ > gMin.vtZ - tol) && (q.vtZ < gMax.vtZ + tol))
	{
	  WLZ_VTX_3_SUB(d, q, p);
	  l = WLZ_VTX_3_SQRLEN(d);
	  if(l < lMSq)
	  {
	    lMSq = l;
	    qM = q;
	  }
	}
	/* Face y = gMax.vtY */
	k = (gMax.vtY - p.vtY) / r.vtY;
	WLZ_VTX_3_SET(q, p.vtX + (k * r.vtX), gMax.vtY, p.vtZ + (k * r.vtZ));
	if((q.vtX > gMin.vtX - tol) && (q.vtX < gMax.vtX + tol) &&
	   (q.vtZ > gMin.vtZ - tol) && (q.vtZ < gMax.vtZ + tol))
	{
	  WLZ_VTX_3_SUB(d, q, p);
	  l = WLZ_VTX_3_SQRLEN(d);
	  if(l < lMSq)
	  {
	    lMSq = l;
	    qM = q;
	  }
	}
      }
      if(fabs(r.vtZ) > tol)
      {
	/* Face z = gMin.vtZ */
        k = (gMin.vtZ - p.vtZ) / r.vtZ;
	WLZ_VTX_3_SET(q, p.vtX + (k * r.vtX), p.vtY + (k * r.vtY), gMin.vtY);
	if((q.vtX > gMin.vtX - tol) && (q.vtX < gMax.vtX + tol) &&
	   (q.vtY > gMin.vtY - tol) && (q.vtY < gMax.vtY + tol))
	{
	  WLZ_VTX_3_SUB(d, q, p);
	  l = WLZ_VTX_3_SQRLEN(d);
	  if(l < lMSq)
	  {
	    lMSq = l;
	    qM = q;
	  }
	}
	/* Face z = gMax.vtZ */
	k = (gMax.vtZ - p.vtZ) / r.vtZ;
	WLZ_VTX_3_SET(q, p.vtX + (k * r.vtX), p.vtY + (k * r.vtY), gMax.vtZ);
	if((q.vtX > gMin.vtX - tol) && (q.vtX < gMax.vtX + tol) &&
	   (q.vtY > gMin.vtY - tol) && (q.vtY < gMax.vtY + tol))
	{
	  WLZ_VTX_3_SUB(d, q, p);
	  l = WLZ_VTX_3_SQRLEN(d);
	  if(l < lMSq)
	  {
	    lMSq = l;
	    qM = q;
	  }
	}
      }
      q.vtX = WLZ_CLAMP(qM.vtX, gMin.vtX, gMin.vtX);
      q.vtY = WLZ_CLAMP(qM.vtY, gMin.vtY, gMin.vtY);
      q.vtZ = WLZ_CLAMP(qM.vtZ, gMin.vtZ, gMin.vtZ);
      idx0 = WlzCMeshCellIdxVtx2D5(mesh, q);
    }
    idx1.vtX = idx1.vtY = idx1.vtZ = 0;
    do
    {
      WLZ_VTX_3_ADD(idx, idx0, idx1);
      if((idx.vtX >= 0) &&
	 (idx.vtY >= 0) &&
	 (idx.vtZ >= 0) &&
	 (idx.vtX < cGrid->nCells.vtX) &&
	 (idx.vtY < cGrid->nCells.vtY) &&
	 (idx.vtZ < cGrid->nCells.vtZ))
      {
	WlzCMeshNod2D5 *nod;
	WlzCMeshCell2D5 *cell;

	/* Look for closest node in this cell. */
	cell = *(*(cGrid->cells + idx.vtZ) + idx.vtY) + idx.vtX;
	nod = cell->nod;
	while(nod)
	{
	  double	d0;
	  WlzDVertex3	d;

	  WLZ_VTX_3_SUB(d, p, nod->pos);
	  d0 = WLZ_VTX_3_SQRLEN(d);
	  if(d0 < minDstSq)
	  {
	    closeNod = nod->idx;
	    minDstSq = d0;
	    if(firstRing < 0)
	    {
	      firstRing = ring;
	    }
	  }
	  nod = nod->next;
	}
      }
      /* Spiral out from the initial grid cell. */
      spiralCnt = WlzGeomItrSpiral3I(spiralCnt,
				     &(idx1.vtX), &(idx1.vtY), &(idx1.vtZ));
      ring = WlzGeomItrSpiralRing(spiralCnt);
      /* Stop spiraling out when the ring after the first in which a node
       * was found has been searched. */
    } while((firstRing < 0) || (ring - firstRing < 2));
  }
  return(closeNod);
}

/*!
* \return	Index of the closest node or a negative number on error.
* \ingroup	WlzMesh
* \brief	Finds the index of the closest node to the given position.
* 		
* 		Finds the index of the closest node to the given position
* 		by spiraling out from the cell containing the given
* 		position.
* \param	mesh			Given mesh.
* \param	pos			Given position.
*/
int		WlzCMeshClosestNod3D(WlzCMesh3D *mesh, WlzDVertex3 pos)
{
  int		ring = 0,
		firstRing = -1,
     		closeNod = -1,
		spiralCnt = 0;
  double	d0,
		minDstSq = DBL_MAX;
  WlzDVertex3	del;
  WlzIVertex3	idx,
  		idx0,
  		idx1;
  WlzCMeshNod3D	*nod;
  WlzCMeshCell3D *cell;

  if(mesh->res.nod.numEnt > 0)
  {
    idx1.vtX = idx1.vtY = idx1.vtZ = 0;
    /* Find grid cell containing the given position. */
    idx0 = WlzCMeshCellIdxVtx3D(mesh, pos);
    do
    {
      WLZ_VTX_3_ADD(idx, idx0, idx1);
      if((idx.vtX >= 0) &&
	 (idx.vtY >= 0) &&
	 (idx.vtZ >= 0) &&
	 (idx.vtX < mesh->cGrid.nCells.vtX) &&
	 (idx.vtY < mesh->cGrid.nCells.vtY) &&
	 (idx.vtZ < mesh->cGrid.nCells.vtZ))
      {
	/* Look for closest node in this cell. */
	cell = *(*(mesh->cGrid.cells + idx.vtZ) + idx.vtY) + idx.vtX;
	nod = cell->nod;
	while(nod)
	{
	  WLZ_VTX_3_SUB(del, pos, nod->pos);
	  d0 = WLZ_VTX_3_SQRLEN(del);
	  if(d0 < minDstSq)
	  {
	    closeNod = nod->idx;
	    minDstSq = d0;
	    if(firstRing < 0)
	    {
	      firstRing = ring;
	    }
	  }
	  nod = nod->next;
	}
      }
      /* Spiral out from the initial grid cell. */
      spiralCnt = WlzGeomItrSpiral3I(spiralCnt,
                                     &(idx1.vtX), &(idx1.vtY), &(idx1.vtZ));
      ring = WlzGeomItrSpiralRing(spiralCnt);
      /* Stop spiraling out when the ring after the first in which a node
       * was found has been searched. */
    } while((firstRing < 0) || (ring - firstRing < 2));
  }
  return(closeNod);
}


/*!
* \return	Non zero if the given vertex is in the given mesh element.
* \ingroup	WlzMesh
* \brief	Checks whether the vertex at the given position is within
* 		the given mesh element.
* \param	elm			Given mesh element.
* \param	gPos			Given vertex position.
*/
int		WlzCMeshElmEnclosesPos2D(WlzCMeshElm2D *elm, WlzDVertex2 gPos)
{
  int		inside = 0;

  if(elm)
  {
    inside = WlzGeomVxInTriangle2D(elm->edu[0].nod->pos, elm->edu[1].nod->pos,
				   elm->edu[2].nod->pos, gPos) >= 0;
  }
  return(inside);
}

/*!
* \return	Non zero if the given vertex is in the given mesh element.
* \ingroup	WlzMesh
* \brief	Checks whether the vertex at the given position is within
* 		the given mesh element.
* \param	elm			Given mesh element.
* \param	gPos			Given vertex position.
*/
int		WlzCMeshElmEnclosesPos2D5(WlzCMeshElm2D5 *elm, WlzDVertex3 gPos)
{
  int		inside = 0;

  if(elm)
  {
    inside = WlzGeomVxInTriangle3D(elm->edu[0].nod->pos, elm->edu[1].nod->pos,
				   elm->edu[2].nod->pos, gPos,
				   WLZ_MESH_TOLERANCE) >= 0;
  }
  return(inside);
}

/*!
* \return	Non zero if the given vertex is in the given mesh element.
* \ingroup	WlzMesh
* \brief	Checks whether the vertex at the given position is within
* 		the given mesh element.
* \param	elm			Given mesh element.
* \param	gPos			Given vertex position.
*/
int		WlzCMeshElmEnclosesPos3D(WlzCMeshElm3D *elm, WlzDVertex3 gPos)
{
  int		inside = 0;
  WlzCMeshNod3D *nod[4];

  if(elm)
  {
    nod[0] = WLZ_CMESH_ELM3D_GET_NODE_0(elm);
    nod[1] = WLZ_CMESH_ELM3D_GET_NODE_1(elm);
    nod[2] = WLZ_CMESH_ELM3D_GET_NODE_2(elm);
    nod[3] = WLZ_CMESH_ELM3D_GET_NODE_3(elm);
    inside = WlzGeomVxInTetrahedron(nod[0]->pos, nod[1]->pos,
    				    nod[2]->pos, nod[3]->pos, gPos) >= 0;
  }
  return(inside);
}

/*!
* \return	New 2D conforming mesh.
* \ingroup	WlzMesh
* \brief	Makes a 2D conforming mesh from the given 2D or 2D5
* 		conforming mesh by simply ignoring the z component (if
* 		it exists) as the node positions are copied.
* 		Node and element indices are preserved by this function.
* \param	gObj			Given conforming mesh object.
* \param	applyDsp		Apply displacement if non-zero and
* 					the given object has valid
* 					displacements in it's indexed values.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzObject	*WlzCMeshExtract2D(WlzObject *gObj, int applyDsp,
				   WlzErrorNum *dstErr)
{
  int		nNod = 0,
  		nElm = 0,
		maxNod = 0,
		maxElm = 0;
  WlzCMeshP	gMeshP;
  WlzIndexedValues *dspIxv = NULL;
  WlzCMesh2D	*rMesh = NULL;
  WlzObject	*rObj = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(gObj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else if((gObj->type != WLZ_CMESH_2D) && (gObj->type != WLZ_CMESH_2D5))
  {
    errNum = WLZ_ERR_OBJECT_TYPE;
  }
  else if((gMeshP.m2d5 = gObj->domain.cm2d5) == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    if((applyDsp != 0) && (gObj->values.core != NULL))
    {
      dspIxv = gObj->values.x;
      if((dspIxv->attach != WLZ_VALUE_ATTACH_NOD) ||
         (dspIxv->rank != 1) || (dspIxv->dim == NULL) || (*(dspIxv->dim) < 2))
      {
        applyDsp = 0;
	dspIxv = NULL;
      }
    }
    switch(gMeshP.m2->type)
    {
      case WLZ_CMESH_2D:
	nElm = gMeshP.m2->res.elm.numEnt;
	nNod = gMeshP.m2->res.nod.numEnt;
	maxElm = gMeshP.m2->res.elm.maxEnt;
	maxNod = gMeshP.m2->res.nod.maxEnt;
	break;
      case WLZ_CMESH_2D5:
	nElm = gMeshP.m2d5->res.elm.numEnt;
	nNod = gMeshP.m2d5->res.nod.numEnt;
	maxElm = gMeshP.m2d5->res.elm.maxEnt;
	maxNod = gMeshP.m2d5->res.nod.maxEnt;
	break;
      default:
	break;
    }
    if(nElm < 1)
    {
      errNum = WLZ_ERR_DOMAIN_DATA;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    rMesh = WlzCMeshNew2D(&errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    if((AlcVectorExtendAndGet(rMesh->res.nod.vec, maxNod) == NULL) ||
       (AlcVectorExtendAndGet(rMesh->res.elm.vec, maxElm) == NULL))
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    int 	idN,
		idE;
    AlcVector	*gNodVec,
		*gElmVec,
    		*rNodVec,
		*rElmVec;

    switch(gMeshP.m2->type)
    {
      case WLZ_CMESH_2D:
	gNodVec = gMeshP.m2->res.nod.vec;
	rNodVec = rMesh->res.nod.vec;
	for(idN = 0; idN < maxNod; ++idN)
	{
	  WlzCMeshNod2D *gNod,
	  		*rNod;

	  gNod = (WlzCMeshNod2D *)AlcVectorItemGet(gNodVec, idN); 
	  rNod = (WlzCMeshNod2D *)AlcVectorItemGet(rNodVec, idN); 
	  rNod->idx = gNod->idx;
	  if(gNod->idx >= 0)
	  {
	    rNod = WlzCMeshAllocNod2D(rMesh);
	    rNod->flags = WLZ_CMESH_NOD_FLAG_NONE;
	    rNod->pos = gNod->pos;
	    if(dspIxv != NULL)
	    {
	      double *dsp;

	      dsp = (double *)WlzIndexedValueGet(dspIxv, idN);
	      rNod->pos.vtX += dsp[0]; 
	      rNod->pos.vtY += dsp[1]; 
	    }
	  }
	}
	rMesh->res.nod.numEnt = nNod;
	rMesh->res.nod.maxEnt = maxNod;
	WlzCMeshUpdateBBox2D(rMesh);
	errNum = WlzCMeshReassignGridCells2D(rMesh, nNod);
	if(errNum == WLZ_ERR_NONE)
	{
	  gElmVec = gMeshP.m2->res.elm.vec;
	  rElmVec = rMesh->res.elm.vec;
	  for(idE = 0; idE < maxElm; ++idE)
	  {
	    WlzCMeshElm2D *gElm,
	    		  *rElm;

	    gElm = (WlzCMeshElm2D *)AlcVectorItemGet(gElmVec, idE);
	    rElm = (WlzCMeshElm2D *)AlcVectorItemGet(rElmVec, idE);
	    rElm->idx = gElm->idx;
	    if(gElm->idx >= 0)
	    {
	      WlzCMeshNod2D *nod[3];

	      for(idN = 0; idN < 3; ++idN)
	      {
		nod[idN] = (WlzCMeshNod2D *)
		           AlcVectorItemGet(rNodVec, gElm->edu[idN].nod->idx);
	      }
              errNum = WlzCMeshSetElm2D(rMesh, rElm, nod[0], nod[1], nod[2],
	                                0);
	      if(errNum == WLZ_ERR_NONE)
	      {
		errNum = WlzCMeshAddElmToGrid2D(rMesh, rElm);
	      }
	      if(errNum != WLZ_ERR_NONE)
	      {
		break;
	      }
	    }
	  }
	}
	if(errNum == WLZ_ERR_NONE)
	{
	  rMesh->res.elm.numEnt = nElm;
	  rMesh->res.elm.maxEnt = maxElm;
	  WlzCMeshUpdateMaxSqEdgLen2D(rMesh);
	}
	break;
      case WLZ_CMESH_2D5:
	gNodVec = gMeshP.m2d5->res.nod.vec;
	rNodVec = rMesh->res.nod.vec;
	for(idN = 0; idN < maxNod; ++idN)
	{
	  WlzCMeshNod2D5 *gNod;
	  WlzCMeshNod2D  *rNod;

	  gNod = (WlzCMeshNod2D5 *)AlcVectorItemGet(gNodVec, idN); 
	  rNod = (WlzCMeshNod2D *)AlcVectorItemGet(rNodVec, idN); 
	  rNod->idx = gNod->idx;
	  if(gNod->idx >= 0)
	  {
	    rNod->flags = WLZ_CMESH_NOD_FLAG_NONE;
	    rNod->pos.vtX = gNod->pos.vtX;
	    rNod->pos.vtY = gNod->pos.vtY;
	    if(dspIxv != NULL)
	    {
	      double *dsp;

	      dsp = (double *)WlzIndexedValueGet(dspIxv, idN);
	      rNod->pos.vtX += dsp[0];
	      rNod->pos.vtY += dsp[1];
	    }
	  }
	}
	rMesh->res.nod.numEnt = nNod;
	rMesh->res.nod.maxEnt = maxNod;
	WlzCMeshUpdateBBox2D(rMesh);
	errNum = WlzCMeshReassignGridCells2D(rMesh, nNod);
	if(errNum == WLZ_ERR_NONE)
	{
	  gElmVec = gMeshP.m2d5->res.elm.vec;
	  rElmVec = rMesh->res.elm.vec;
	  for(idE = 0; idE < maxElm; ++idE)
	  {
	    WlzCMeshElm2D  *rElm;
	    WlzCMeshElm2D5 *gElm;

	    gElm = (WlzCMeshElm2D5 *)AlcVectorItemGet(gElmVec, idE);
	    rElm = (WlzCMeshElm2D *)AlcVectorItemGet(rElmVec, idE);
	    rElm->idx = gElm->idx;
	    if(gElm->idx >= 0)
	    {
	      WlzCMeshNod2D *nod[3];

	      for(idN = 0; idN < 3; ++idN)
	      {
		nod[idN] = (WlzCMeshNod2D *)
		           AlcVectorItemGet(rNodVec, gElm->edu[idN].nod->idx);
	      }
	      errNum = WlzCMeshSetElm2D(rMesh, rElm, nod[0], nod[1], nod[2],
	                                1);
	      if(errNum == WLZ_ERR_NONE)
	      {
		errNum = WlzCMeshAddElmToGrid2D(rMesh, rElm);
	      }
	      if(errNum != WLZ_ERR_NONE)
	      {
		break;
	      }
	    }
	  }
	}
	if(errNum == WLZ_ERR_NONE)
	{
	  rMesh->res.elm.numEnt = nElm;
	  rMesh->res.elm.maxEnt = maxElm;
	  WlzCMeshUpdateMaxSqEdgLen2D(rMesh);
	}
	break;
      default:
        errNum = WLZ_ERR_OBJECT_TYPE;
	break;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    WlzDomain dom;
    WlzValues val;

    dom.cm2 = rMesh;
    val.core = NULL;
    rObj = WlzMakeMain(WLZ_CMESH_2D, dom, val, NULL, NULL, &errNum);
  }
  if(errNum != WLZ_ERR_NONE)
  {
    (void )WlzCMeshFree2D(rMesh);
  }
  if(dstErr != NULL)
  {
    *dstErr = errNum;
  }
  return(rObj);
}

/*!
* \return	New mesh or NULL on error.
* \ingroup	WlzMesh
* \brief	Constructs a 2D or 3D mesh from a 2D or 3D domain object.
*		Because of the difficulty in computing a mesh which conforms
*		to the domain of the given object, the resulting mesh will
*		instead cover the given domain with some nodes of the
*		mesh outside the given domain. All mesh nodes will however
*		be within the dilated domain, where the dilation is by a sphere
*		of radius twice the minimum element size.
* \param	obj			Given domain object.
* \param	minElmSz		Minimum element size.
* \param	maxElmSz		Minimum element size.
* \param	dstDilObj		Destination pointer for the dilated
*					object used to build the mesh.
* \param	conform			If non-zero make the mesh conform to
* 					the object's domain.
*					outside the object if non-zero.
* \param	dstErr			Destination error pointer may be NULL.
*/
WlzCMeshP	WlzCMeshFromObj(WlzObject *obj,
				double minElmSz, double maxElmSz,
				WlzObject **dstDilObj, int conform,
				WlzErrorNum *dstErr)
{
  WlzCMeshP	mesh;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  mesh.v = NULL;
  if(obj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else
  {
    switch(obj->type)
    {
      case WLZ_2D_DOMAINOBJ:
        mesh.m2 = WlzCMeshFromObj2D(obj, minElmSz, maxElmSz, dstDilObj,
		                    conform, &errNum);
        break;
      case WLZ_3D_DOMAINOBJ:
        mesh.m3 = WlzCMeshFromObj3D(obj, minElmSz, maxElmSz, dstDilObj,
		                    conform, &errNum);
        break;
      default:
        errNum = WLZ_ERR_OBJECT_TYPE;
	break;
    }
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	New mesh or NULL on error.
* \ingroup	WlzMesh
* \brief	Constructs a 2D mesh from a 2D domain object.
*		Because of the difficulty in computing a mesh which conforms
*		to the domain of the given object, the resulting mesh will
*		instead cover the given domain with some nodes of the
*		mesh outside the given domain. All mesh nodes will however
*		be within the dilated domain, where the dilation is by a sphere
*		of radius twice the minimum element size.
* \param	obj			Given domain object.
* \param	minElmSz		Minimum element size.
* \param	maxElmSz		Minimum element size.
* \param	dstDilObj		Destination pointer for the dilated
*					object used to build the mesh,
*					may be NULL.
* \param	conform			If non-zero make boundary elements
* 					conform to the given domain by
* 					decomposing them. Any elements with
* 					all nodes outside the given domain
* 					are deleted.
* \param	dstErr			Destination error pointer may be NULL.
*/
WlzCMesh2D	*WlzCMeshFromObj2D(WlzObject *obj,
				   double minElmSz, double maxElmSz,
				   WlzObject **dstDilObj, int conform,
				   WlzErrorNum *dstErr)
{
  int		scale = 1,
  		maxLBTNdSz = 1;
  double	dilation,
  		invScale = 1.0;
  WlzCMesh2D	*mesh = NULL;
  WlzLBTDomain2D *lDom = NULL;
  WlzObject	*dilObj = NULL,
  		*idxObj = NULL,
  		*sclObj = NULL,
		*strObj = NULL;
  WlzAffineTransform *tr = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(obj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else if(obj->type != WLZ_2D_DOMAINOBJ)
  {
    errNum = WLZ_ERR_OBJECT_TYPE;
  }
  else if(obj->domain.core == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(minElmSz < 1.0)
  {
    errNum = WLZ_ERR_PARAM_DATA;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    if(minElmSz < 1.0)
    {
      minElmSz = 1.0;
    }
    scale = (int )ceil(minElmSz);
    dilation = scale + 1.0;
    maxLBTNdSz = (int )ceil(maxElmSz / minElmSz);
    if(maxLBTNdSz < 1)
    {
      maxLBTNdSz = 1;
    }
    invScale = 1.0 / scale;
    strObj = WlzAssignObject(
             WlzMakeRectangleObject(dilation, dilation,
	                            0.0, 0.0, &errNum), NULL);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    dilObj = WlzAssignObject(
    	     WlzStructDilation(obj, strObj, &errNum), NULL);
  }
  (void )WlzFreeObj(strObj); strObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    tr = WlzMakeAffineTransform(WLZ_TRANSFORM_2D_AFFINE, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    (void )WlzAffineTransformScaleSet(tr, invScale, invScale, invScale);
    sclObj = WlzAffineTransformObj(dilObj, tr, WLZ_INTERPOLATION_NEAREST,
				   &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    lDom = WlzLBTDomain2DFromDomain(sclObj->domain, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    idxObj = WlzLBTMakeNodeIndexObj2D(lDom, sclObj->domain.i, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzLBTBalanceDomain2D(lDom, idxObj, maxLBTNdSz, 0);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzLBTIndexObjSetAllNodes2D(lDom, idxObj);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh = WlzCMeshFromBalLBTDom2D(lDom, idxObj, &errNum);
  }
  (void )WlzFreeLBTDomain2D(lDom);
  WlzFreeObj(idxObj); idxObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    (void )WlzAffineTransformScaleSet(tr, scale, scale, scale);
    errNum = WlzCMeshAffineTransformMesh2D(mesh, tr);
  }
  (void )WlzFreeObj(sclObj);
  (void )WlzFreeAffineTransform(tr);
  WlzFreeObj(dilObj); dilObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    dilation = 1.0;
    strObj = WlzAssignObject(
             WlzMakeCircleObject(dilation, 0.0, 0.0, &errNum), NULL);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    dilObj = WlzAssignObject(
    	     WlzStructDilation(obj, strObj, &errNum), NULL);
  }
  (void )WlzFreeObj(strObj);
  if((errNum == WLZ_ERR_NONE) && (conform != 0))
  {
    /* Don't use the increment method of WlzCMeshBoundConform2D() it may
     * give zero area elements, instead use the bisection method. */
    errNum = WlzCMeshBoundConform2D(mesh, dilObj, 0, 0.5);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    WlzCMeshUpdateBBox2D(mesh);
    WlzCMeshUpdateMaxSqEdgLen2D(mesh);
    errNum = WlzCMeshReassignGridCells2D(mesh, 0);
  }
  if((errNum == WLZ_ERR_NONE) && dstDilObj)
  {
    *dstDilObj = dilObj;
  }
  else
  {
    WlzFreeObj(dilObj);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	New mesh or NULL on error.
* \ingroup	WlzMesh
* \brief	Constructs a 3D mesh from a 3D domain object.
* \param	obj			Given domain object.
* \param	minElmSz		Minimum element size.
* \param	maxElmSz		Minimum element size.
* \param	dstDilObj		Destination pointer for the dilated
*					object used to build the mesh,
*					may be NULL.
* \param	conform			If non-zero make boundary elements
* 					conform to the given domain by
* 					decomposing them. Any elements with
* 					all nodes outside the given domain
* 					are deleted.
* \param	dstErr			Destination error pointer may be NULL.
*/
WlzCMesh3D	*WlzCMeshFromObj3D(WlzObject *obj,
				   double minElmSz, double maxElmSz,
				   WlzObject **dstDilObj, int conform,
			           WlzErrorNum *dstErr)
{
  int		scale = 1,
  		maxLBTNdSz = 1;
  double	dilation,
  		invScale = 1.0;
  WlzCMesh3D	*mesh = NULL;
  WlzLBTDomain3D *lDom = NULL;
  WlzAffineTransform *tr = NULL;
  WlzObject	*dilObj = NULL,
  		*idxObj = NULL,
  		*sclObj = NULL,
		*strObj = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(obj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else if(obj->type != WLZ_3D_DOMAINOBJ)
  {
    errNum = WLZ_ERR_OBJECT_TYPE;
  }
  else if(obj->domain.core == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(minElmSz < 1.0)
  {
    errNum = WLZ_ERR_PARAM_DATA;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    if(minElmSz < 1.0)
    {
      minElmSz = 1.0;
    }
    scale = (int )ceil(minElmSz);
    dilation = scale  + 1.0;
    maxLBTNdSz = (int )ceil(maxElmSz / minElmSz);
    if(maxLBTNdSz < 1)
    {
      maxLBTNdSz = 1;
    }
    invScale = 1.0 / scale;
    strObj = WlzAssignObject(
	     WlzMakeCuboidObject(WLZ_3D_DOMAINOBJ,
				dilation, dilation, dilation,
				 0.0, 0.0, 0.0, &errNum), NULL);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    dilObj = WlzAssignObject(
	     WlzStructDilation(obj, strObj, &errNum), NULL);
  }
  (void )WlzFreeObj(strObj); strObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    tr = WlzMakeAffineTransform(WLZ_TRANSFORM_3D_AFFINE, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    (void )WlzAffineTransformScaleSet(tr, invScale, invScale, invScale);
    sclObj = WlzAffineTransformObj(dilObj, tr, WLZ_INTERPOLATION_NEAREST,
				   &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    lDom = WlzLBTDomain3DFromDomain(sclObj->domain, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    idxObj = WlzLBTMakeNodeIndexObj3D(lDom, sclObj->domain.p, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzLBTBalanceDomain3D(lDom, idxObj, maxLBTNdSz, 0);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzLBTIndexObjSetAllNodes3D(lDom, idxObj);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh = WlzCMeshFromBalLBTDom3D(lDom, idxObj, &errNum);
  }
  (void )WlzFreeLBTDomain3D(lDom);
  WlzFreeObj(idxObj); idxObj = NULL;
  if(errNum == WLZ_ERR_NONE)
  {
    (void )WlzAffineTransformScaleSet(tr, scale, scale, scale);
    errNum = WlzCMeshAffineTransformMesh3D(mesh, tr);
  }
  WlzFreeObj(dilObj); dilObj = NULL;
  if((errNum == WLZ_ERR_NONE) && dstDilObj)
  {
    dilObj = WlzAffineTransformObj(sclObj, tr, WLZ_INTERPOLATION_NEAREST,
    				   &errNum);
    *dstDilObj = dilObj;
  }
  (void )WlzFreeObj(sclObj);
  (void )WlzFreeAffineTransform(tr);
  if((errNum == WLZ_ERR_NONE) && (conform != 0))
  {
    /* Don't use the increment method of WlzCMeshBoundConform3D() it may
     * give zero volume elements, instead use the bisection method. */
    errNum = WlzCMeshBoundConform3D(mesh, obj, 0, 0.5);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    WlzCMeshUpdateBBox3D(mesh);
    WlzCMeshUpdateMaxSqEdgLen3D(mesh);
    errNum = WlzCMeshReassignGridCells3D(mesh, 0);
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return	New mesh or NULL on error.
* \ingroup	WlzMesh
* \brief	Constructs a 2D5 mesh from a 3D geometric model.
* \param	model			The given model which must be 2D.
* \param	dstErr			Destination error pointer may be NULL.
*/
WlzCMesh2D5	*WlzCMeshFromGM(WlzGMModel *model, WlzErrorNum *dstErr)
{
  int		nElm,
  		nNod,
		maxFce,
		maxVtx;
  WlzCMesh2D5	*mesh = NULL;
  WlzGMResIdxTb	*resIdxTb = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(model == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else
  {
    switch(model->type)
    {
      case WLZ_GMMOD_3I:
      case WLZ_GMMOD_3D:
      case WLZ_GMMOD_3N:
        break;
      default:
        errNum = WLZ_ERR_DOMAIN_TYPE;
	break;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
     /* Index the verticies. */
     resIdxTb = WlzGMModelResIdx(model, WLZ_GMELMFLG_VERTEX, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    maxFce = model->res.face.numIdx;
    maxVtx = model->res.vertex.numIdx;
    if(((nNod = model->res.vertex.numElm) < 3) ||
       ((nElm = model->res.face.numElm) < 1))
    {
      errNum = WLZ_ERR_DOMAIN_DATA;
    }
  }
  /* Create the mesh. */
  if(errNum == WLZ_ERR_NONE)
  {
    mesh = WlzCMeshNew2D5(&errNum);
  }
  /* Create the mesh nodes and elements. */
  if(errNum == WLZ_ERR_NONE)
  {
    if((AlcVectorExtendAndGet(mesh->res.nod.vec, nNod) == NULL) ||
       (AlcVectorExtendAndGet(mesh->res.elm.vec, nElm) == NULL))
    {
      errNum = WLZ_ERR_MEM_ALLOC;
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    int	idV;
    AlcVector *vec;

    vec = model->res.vertex.vec;
    for(idV = 0; idV < maxVtx; ++idV)
    {
      WlzGMVertex *vtx;
      WlzCMeshNod2D5 *nod;

      vtx = (WlzGMVertex *)AlcVectorItemGet(vec, idV);
      if(vtx->idx >= 0)
      {
	nod = WlzCMeshAllocNod2D5(mesh);
	nod->flags = WLZ_CMESH_NOD_FLAG_NONE;
	(void )WlzGMVertexGetG3D(vtx, &(nod->pos));
      }
    }
    WlzCMeshUpdateBBox2D5(mesh);
    WlzCMeshUpdateMaxSqEdgLen2D5(mesh);
    errNum = WlzCMeshReassignGridCells2D5(mesh, nNod);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    int	idF;
    AlcVector *vec;

    vec = model->res.face.vec;
    for(idF = 0; idF < maxFce; ++idF)
    {
      WlzGMFace *fce;

      fce = (WlzGMFace *)AlcVectorItemGet(vec, idF);
      if(fce->idx >= 0)
      {
	int	tI;
	WlzGMEdgeT *tET;
	WlzCMeshNod2D5 *nod[3];

	tET = fce->loopT->edgeT;
	tI = *(resIdxTb->vertex.idxLut +
	       tET->vertexT->diskT->vertex->idx);
	if((tI < 0) && (tI >= nNod))
	{
	  errNum = WLZ_ERR_DOMAIN_DATA;
	  break;
	}
	nod[0] = (WlzCMeshNod2D5 *)AlcVectorItemGet(mesh->res.nod.vec, tI);
        tI = *(resIdxTb->vertex.idxLut +
	       tET->next->vertexT->diskT->vertex->idx);
	if((tI < 0) && (tI >= nNod))
	{
	  errNum = WLZ_ERR_DOMAIN_DATA;
	  break;
	}
	nod[1] = (WlzCMeshNod2D5 *)AlcVectorItemGet(mesh->res.nod.vec, tI);
	tI = *(resIdxTb->vertex.idxLut +
	       tET->prev->vertexT->diskT->vertex->idx);
	if((tI < 0) && (tI >= nNod))
	{
	  errNum = WLZ_ERR_DOMAIN_DATA;
	  break;
	}
	nod[2] = (WlzCMeshNod2D5 *)AlcVectorItemGet(mesh->res.nod.vec, tI);
        (void )WlzCMeshNewElm2D5(mesh, nod[0], nod[1], nod[2], 0, &errNum);
	if(errNum != WLZ_ERR_NONE)
	{
	  break;
	}
      }
    }
  }
  if(errNum != WLZ_ERR_NONE)
  {
    (void )WlzCMeshFree2D5(mesh);
    mesh = NULL;
  }
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return       New mesh or NULL on error.
* \ingroup      WlzMesh
* \brief        Constructs a 2D mesh from a balanced 2D linear binary
*		tree domain.
* \param	lDom			Linear binary tree domain.
* \param	iObj			Index object for lDom.
* \param        dstErr			Destination error pointer may be NULL.
*/
WlzCMesh2D	*WlzCMeshFromBalLBTDom2D(WlzLBTDomain2D *lDom, WlzObject *iObj,
				         WlzErrorNum *dstErr)
{
  int		idN;
  WlzIVertex2	bSz;
  WlzCMesh2D	*mesh = NULL;
  WlzGreyValueWSpace *iGVWSp = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(lDom == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(iObj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else
  {
    mesh = WlzCMeshNew2D(&errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    iGVWSp = WlzGreyValueMakeWSp(iObj, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->bBox.xMin = lDom->kol1;
    mesh->bBox.yMin = lDom->line1;
    mesh->bBox.xMax = lDom->lastkl;
    mesh->bBox.yMax = lDom->lastln;
    bSz.vtX = mesh->bBox.xMax - mesh->bBox.xMin;
    bSz.vtY = mesh->bBox.yMax - mesh->bBox.yMin;
    if((lDom->nNodes <= 0) || (bSz.vtX < 1.0) || (bSz.vtY < 1.0))
    {
      errNum = WLZ_ERR_DOMAIN_DATA;
    }
  }
  /* Create an initial grid of cells. */
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshReassignGridCells2D(mesh, lDom->nNodes * 4);
  }
  /* Add the LBT nodes to the mesh. */
  if(errNum == WLZ_ERR_NONE)
  {
    idN = 0;
    while((errNum == WLZ_ERR_NONE) && (idN < lDom->nNodes))
    {
      errNum = WlzCMeshAddLBTNode2D(mesh, lDom, iGVWSp, idN);
      ++idN;
    }
  }
  /* Free temporary storage. */
  WlzGreyValueFreeWSp(iGVWSp);
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return       New mesh or NULL on error.
* \ingroup      WlzMesh
* \brief        Constructs a 3D mesh from a balanced 3D linear binary
*		tree domain.
*
* For tesselation of a 3D LBT node, each node is condidered to be a cube.
* This can conviniently be represented by it's net and using this
* representation there are 10 possible node-neighbour relationships
* when the rotational degeneracy is ignored:
\verbatim
      Y ^        f1
        | v4     |        v5
        |/       |       /
        *---------------@
        |\       :      :\
        | \      :      : \     f2
        |  \     :      :  \  /
        |   \      f5   :   \/
        |    \          :   .\
     v0 |     \   v7    :  .  \   v6
       \|      \ /      :      \ /
        @...f4..@-------*-------*---->X
         \      |      / .      |
          \     |     v1  .     |
           \    |          .    |
            \   |    . f3   .   |
             \  |     .      .  |
              \ | v3   .      . | v2
               \|/      .      .|/
                @---------------@
                 \        \
                  \        \
                 Z %        f0
                 
\endverbatim
* Faces are defined to have the following orientations, when viewed from
* outside the cube:
\verbatim
          +z          +y          +y          +y          +y          +x
       3-----2     5-----4     6-----5     7-----6     4-----7     5-----6
       |     |     |     |     |     |     |     |     |     |     |     |
     -x|  0  |+x +x|  1  |-x +z|  2  |-z -x|  3  |+x -z|  4  |+z -z|  5  |+z
       |   -y|     |   -z|     |   +x|     |   +z|     |   -x|     |   +y|
       0-----1     1-----0     2-----1     3-----2     0-----3     4-----7
          -z          -y          -y          -y          -y          -x
\endverbatim
* The neighbouring nodes to each of these faces can be found using 3
* orthogonal vectors (looking from outside the cube):
\verbatim
          ^     
       o2 |     
          |        
       +--|--+               o3 = -o1
       |     |               o4 = -o2
 o3 <---     ----> o1
       |    \|    
       +--|--\    
          |   % o0  
       o4 |     
          V     
\endverbatim
* Nets of the LBT node cube looking from outside the cube
\verbatim
        3---2            +-+-+            +-+-+            +-+-+
      0 |   |          1 | | |          2 | | |          3 | | |
        | 0 |            +-+-+            +-+-+            +-+-+
        |   |            | | |            | | |            | | |
        0---1            +-+-+            +-+-+            +-+-+
        |   |            |   |            | | |            |   |
        | 1 |            |   |            +-+-+            |   |
        |   |            |   |            | | |            |   |
    0---4---5---1    +---+---+---+    +---+-+-+---+    +---+-+-+---+
    |   |   |   |    |   |   |   |    |   |   |   |    |   | | |   |
    | 4 | 5 | 2 |    |   |   |   |    |   |   |   |    |   +-+-+   |
    |   |   |   |    |   |   |   |    |   |   |   |    |   | | |   |
    3---7---6---2    +---+---+---+    +---+---+---+    +---+-+-+---+
        |   |            |   |            |   |            |   |
        | 3 |            |   |            |   |            |   |
        |   |            |   |            |   |            |   |
        3---2            +---+            +---+            +---+

        +-+-+            +-+-+            +-+-+            +-+-+
      4 | | |          5 | | |          6 | | |          7 | | |
        +-+-+            +-+-+            +-+-+            +-+-+
        | | |            | | |            | | |            | | |
        +-+-+            +---+            +-+-+            +-+-+
        | | |            | | |            | | |            | | |
        +-+-+            +-+-+            +-+-+            +-+-+
        | | |            | | |            | | |            | | |
    +---+-+-+---+    +---+---+-+-+    +---+---+---+    +---+-+-+---+
    |   | | |   |    |   |   | | |    | | |   | | |    |   | | |   |
    |   +-+-+   |    |   |   +-+-+    +-+-+   +-+-+    |   +-+-+   |
    |   | | |   |    |   |   | | |    | | |   | | |    |   | | |   |
    +---+-+-+---+    +---+---+-+-+    +---+---+---+    +---+-+-+---+
        |   |            |   |            |   |            | | |
        |   |            |   |            |   |            +-+-+
        |   |            |   |            |   |            | | |
        +---+            +---+            +---+            +-+-+

        +-+-+            +-+-+
      8 | | |          9 | | |
        +-+-+            +-+-+
        | | |            | | |
        +-+-+            +-+-+
        | | |            | | |
        +-+-+            +-+-+
        | | |            | | |
    +-+-+-+-+-+-+    +-+-+-+-+-+-+
    | | | | | | |    | | | | | | |
    +-+-+-+-+-+-+    +-+-+-+-+-+-+
    | | | | | | |    | | | | | | |
    +-+-+-+-+-+-+    +-+-+-+-+-+-+
        |   |            | | |
        |   |            +-+-+
        |   |            | | |
        +---+            +---+
\endverbatim
* By placing a mesh node at the centre of the cube, each face can be
* tesselated with tetrahedra almost independently of the other faces.
* This gives the following possible teselations, in which each facet
* on the cubes surface forms a tetrahedron with the node at the cubes
* centre. Here the cube faces which share an edge obviously influence
* the tesselation of a face and so reduce the number of classes to 6:
\verbatim
        +---+            +-+-+            +-+-+            +-+-+
  0=(0) |\ /|      1=(1) |\|/|      2=(2) |\|/|      3=(3) |\|/|
        | X |            +-X-+            +-X-+            +-X-+
        |/ \|            |/|\|            |/|\|            |/|\|
        +---+            +-+-+            +-+-+            +-+-+
        |\ /|            |\|/|            |\|/|            |\|/|
        | X |            | X |            +-X-+            | X |
        |/ \|            |/ \|            |/|\|            |/|\|
    +---+---+---+    +---+---+---+    +-+-+---+-+-+    +---+-+-+---+
    |\ /|\ /|\ /|    |\ /|\ /|\ /|    |\|/|\|/|\|/|    |\ /|\|/|\ /|
    | X | X | X |    +-X | X | X-+    +-X | X | X-+    +-X-+-X-+-X-+
    |/ \|/ \|/ \|    |/ \|/ \|/ \|    |/ \|/ \|/ \|    |/ \|/|\|/ \|
    +---+---+---+    +---+---+---+    +---+---+---+    +---+-+-+---+
        |\ /|            |\ /|            |\ /|            |\|/|
        | X |            | X |            | X |            | X |
        |/ \|            |/|\|            |/|\|            |/|\|
        +---+            +-+-+            +-+-+            +-+-+

        +-+-+            +-+-+            +-+-+            +-+-+
  4=(4) |\|/|      5=(5) |\|/|      6=(6) |\|/|  7=(7,8,9) |\|/|
        +-X-+            +-X-+            +-X-+            +-X-+
        |/|\|            |/|\|            |/|\|            |/|\|
        +-+-+            +-+-+            +-+-+            +-+-+
        |\|/|            |\|/|            |\|/|            |\|/|
        +-X-+            +-X-+            +-X-+            +-X-+
        |/|\|            |/|\|            |/|\|            |/|\|
    +-+-+-+-+-+-+    +-+-+-+-+-+-+    +---+-+-+---+    +-+-+-+-+-+-+
    |\|/|\|/|\|/|    |\|/|\|/|\|/|    |\ /|\|/|\ /|    |\|/|\|/|\|/|
    +-X-+-X-+-X-+    +-X | X-+-X-+    +-X-+-X-+-X-+    +-X-+-X-+-X-+
    |/ \|/|\|/ \|    |/ \|/ \|/|\|    |/|\|/ \|/|\|    |/|\|/|\|/|\|
    +---+-+-+---+    +---+---+-+-+    +-+-+---+-+-+    +-+-+-+-+-+-+
        |\|/|            |\ /|            |\ /|            |\|/|
        | X |            | X-+            +-X-+            +-X-+
        |/|\|            |/|\|            |/|\|            |/|\|
        +-+-+            +-+-+            +-+-+            +-+-+
\endverbatim
* These possible cube face tesselations lead to 6 possible cube face
* tesselations which define struct::_WlzLBTNodeClass2D.
*
* \param	lDom			Linear binary tree domain.
* \param	iObj			Index object for lDom.
* \param        dstErr			Destination error pointer may be NULL.
*/
WlzCMesh3D	*WlzCMeshFromBalLBTDom3D(WlzLBTDomain3D *lDom, WlzObject *iObj,
				         WlzErrorNum *dstErr)
{
  int		idN;
  WlzIVertex3	bSz;
  WlzCMesh3D	*mesh = NULL;
  WlzGreyValueWSpace *iGVWSp = NULL;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(lDom == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(iObj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else
  {
    mesh = WlzCMeshNew3D(&errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    iGVWSp = WlzGreyValueMakeWSp(iObj, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mesh->bBox.xMin = lDom->kol1;
    mesh->bBox.yMin = lDom->line1;
    mesh->bBox.zMin = lDom->plane1;
    mesh->bBox.xMax = lDom->lastkl;
    mesh->bBox.yMax = lDom->lastln;
    mesh->bBox.zMax = lDom->lastpl;
    bSz.vtX = mesh->bBox.xMax - mesh->bBox.xMin;
    bSz.vtY = mesh->bBox.yMax - mesh->bBox.yMin;
    bSz.vtZ = mesh->bBox.zMax - mesh->bBox.zMin;
    if((lDom->nNodes <= 0) ||
       (bSz.vtX < 1.0) || (bSz.vtY < 1.0) || (bSz.vtZ < 1.0))
    {
      errNum = WLZ_ERR_DOMAIN_DATA;
    }
  }
  /* Create an initial grid of cells. */
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshReassignGridCells3D(mesh, lDom->nNodes * 4);
  }
  /* Add the LBT nodes to the mesh. */
  if(errNum == WLZ_ERR_NONE)
  {
    idN = 0;
    while((errNum == WLZ_ERR_NONE) && (idN < lDom->nNodes))
    {
      errNum = WlzCMeshAddLBTNode3D(mesh, lDom, iGVWSp, idN);
      ++idN;
    }
  }
  /* Free temporary storage. */
  WlzGreyValueFreeWSp(iGVWSp);
  if(dstErr)
  {
    *dstErr = errNum;
  }
  return(mesh);
}

/*!
* \return       Woolz error code.
* \ingroup      WlzMesh
* \brief        Adds a balanced LBT node to a 2D mesh.
*		LBT nodes which have the boundary flag set result in
*		mesh elements which hae the boundary flag set.
* \param	mesh			The mesh.
* \param	lDom			Linear binary tree domain.
* \param	iGVWSp			Grey workspace for index object.
* \param        idN			Index of the LBT node.
*/
static WlzErrorNum WlzCMeshAddLBTNode2D(WlzCMesh2D *mesh,
					WlzLBTDomain2D *lDom,
				        WlzGreyValueWSpace *iGVWSp,
					int idN)
{
  int		rot,
  		nElm,
		nNod;
  WlzLBTNodeClass2D cls;
  WlzDVertex2	nPos[8];
  WlzCMeshNod2D	*mNod[8];
  WlzCMeshElm2D	*mElm[6];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Classify the LBT node. */
  WlzLBTClassifyNode2D(lDom, iGVWSp, idN, &cls, &rot);
  /* Compute mesh node positions. */
  nNod = WlzCMeshCompLBTNodPos2D(nPos, lDom, idN,  cls, rot);
  /* Match mesh nodes to computed positions. */
  (void )WlzCMeshMatchNNod2D(mesh, nNod, nPos, WLZ_MESH_TOLERANCE, mNod);
  /* Create nodes that don't already exist. */
  for(idN = 0; idN < nNod; ++idN)
  {
    if(mNod[idN] == NULL)
    {
      mNod[idN] = WlzCMeshNewNod2D(mesh, nPos[idN], &errNum);
      if(errNum != WLZ_ERR_NONE)
      {
        break;
      }
    }
  }
  if(errNum == WLZ_ERR_NONE)
  {
    /* Create new mesh elements. */
    errNum = WlzCMeshElmFromLBTNode2D(mesh, nPos, mElm, mNod, cls, &nElm);
  }
#ifdef WLZ_CMESH_DEBUG_MESH
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify2D(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return       Woolz error code.
* \ingroup      WlzMesh
* \brief        Adds a balanced LBT node to a 3D mesh.
*		LBT nodes which have the boundary flag set result in
*		mesh elements which hae the boundary flag set.
* \param	mesh			The mesh.
* \param	lDom			Linear binary tree domain.
* \param	iGVWSp			Grey workspace for index object.
* \param        idN			Index of the LBT node.
*/
static WlzErrorNum WlzCMeshAddLBTNode3D(WlzCMesh3D *mesh,
					WlzLBTDomain3D *lDom,
				        WlzGreyValueWSpace *iGVWSp,
					int idN)
{
  int		idF,
		idM,
		rot,
		nNod;
  WlzIBox3	nBB;
  WlzDVertex3	vtx[8];
  WlzLBTNodeClass2D cls; /* The 2D node classification is valid for faces. */
  WlzDVertex3	nPos[27]; /* Nodes at cube vertices (8), edge midpoints (12),
                             face centres (6) and cube centre (1) = 27. */
  WlzCMeshElm3D *mElm[8];
  WlzCMeshNod3D	*mNod[10];
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* For each face of the LBT node's cube:
   * Compute the tesselation of the cube face.
   * Form tetrahedra from the vertices of these triangles and the centre of
   * the cube, resulting in a pyramid of tetrahedra.
   * Join tesselated pyramids to the existing mesh.
   */
  idF = 0;
  WlzLBTKeyToBox3I((lDom->nodes + idN)->keys, &nBB);
#ifdef WLZ_CMESH_DEBUG_MESH
  (void )fprintf(stderr, "WlzCMeshAddLBTNode3D() "
                         "% 6d % 6d % 6d % 6d % 6d % 6d\n",
			 nBB.xMin, nBB.yMin, nBB.zMin,
			 nBB.xMax, nBB.yMax, nBB.zMax);
#endif
  /* These vertices are the "origin" vertices for the faces of the
   * LBT node as defined in the comments for WlzCMeshFromBalLBTDom3D(). */
  vtx[0].vtX = nBB.xMin;       /* face = 0, vertex = 0 */
  vtx[0].vtY = nBB.yMin;
  vtx[0].vtZ = nBB.zMin;
  vtx[1].vtX = nBB.xMax + 1.0; /* face = 1, vertex = 1 */
  vtx[1].vtY = nBB.yMin;
  vtx[1].vtZ = nBB.zMin;
  vtx[2].vtX = nBB.xMax + 1.0; /* face = 2, vertex = 2 */
  vtx[2].vtY = nBB.yMin;
  vtx[2].vtZ = nBB.zMax + 1.0;
  vtx[3].vtX = nBB.xMin;       /* face = 3, vertex = 3 */
  vtx[3].vtY = nBB.yMin;
  vtx[3].vtZ = nBB.zMax + 1.0;
  vtx[4].vtX = nBB.xMin;       /* face = 4, vertex = 0 */
  vtx[4].vtY = nBB.yMin;
  vtx[4].vtZ = nBB.zMin;
  vtx[5].vtX = nBB.xMin;       /* face = 5, vertex = 4 */
  vtx[5].vtY = nBB.yMax + 1.0;
  vtx[5].vtZ = nBB.zMin;
  while((errNum == WLZ_ERR_NONE) && (idF < 6))
  {
    /* Classify the cube face. */
    WlzLBTClassifyNodeFace3D(lDom, iGVWSp, idN, idF, vtx, &cls, &rot);
    /* Compute the positions of the mesh nodes. */
    nNod = WlzCMeshCompLBTFceNodPos3D(nPos, lDom, idN,  idF, cls, rot);
    /* Match mesh nodes to computed positions. */
    (void )WlzCMeshMatchNNod3D(mesh, nNod, nPos, WLZ_MESH_TOLERANCE, mNod);
    /* Create nodes that don't already exist. */
    for(idM = 0; idM < nNod; ++idM)
    {
      if(mNod[idM] == NULL)
      {
	mNod[idM] = WlzCMeshNewNod3D(mesh, nPos[idM], &errNum);
	if(errNum != WLZ_ERR_NONE)
	{
	  break;
	}
      }
    }
    if(errNum == WLZ_ERR_NONE)
    {
      /* Create new mesh elements. */
      errNum = WlzCMeshElmFromLBTNode3D(mesh, nPos, mElm, mNod, cls);
    }
    ++idF;
  }
#ifdef WLZ_CMESH_DEBUG_MESH
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzCMeshVerify3D(mesh, NULL, 1, stderr);
  }
#endif
  return(errNum);
}

/*!
* \return	Number of nodes for the given LBT domain node.
* \ingroup	WlzMesh
* \brief	Computes the positions of the mesh nodes for the given
*		2D LBT domain node.
* \param	nPos			Array for node positions.
* \param	lDom			LBT domain.
* \param	idN			Index of LBT node.
* \param	cls			LBT node adjacency class.
* \param	rot			LBT node rotation from class.
*/
static int	WlzCMeshCompLBTNodPos2D(WlzDVertex2 *nPos,
				      WlzLBTDomain2D *lDom,
				      int idN,  WlzLBTNodeClass2D cls, int rot)
{
  int		nNod = 0;
  double	tD0,
  		hWidth,
		width;
  WlzIVertex2	lPos;

  /* Compute LBT node's position and size / 2. */
  WlzLBTKeyToPos2I((lDom->nodes + idN)->keys, &lPos);
  width = (double )WlzLBTNodeSz2D(lDom->nodes + idN);
  hWidth = width / 2.0;
  /* Set relative mesh node positions without rotation or offset. */
  switch(cls)
  {
    case WLZ_LBT_NODE_CLASS_2D_0:
      nNod  = 4;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = width;  nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = width;
      nPos[3].vtX = 0.0;    nPos[3].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_1:
      nNod  = 5;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = width;  nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = width;
      nPos[3].vtX = hWidth; nPos[3].vtY = width;
      nPos[4].vtX = 0.0;    nPos[4].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_2:
      nNod  = 6;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = width;  nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = hWidth;
      nPos[3].vtX = width;  nPos[3].vtY = width;
      nPos[4].vtX = hWidth; nPos[4].vtY = width;
      nPos[5].vtX = 0.0;    nPos[5].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_3:
      nNod  = 6;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = hWidth; nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = 0.0;
      nPos[3].vtX = width;  nPos[3].vtY = width;
      nPos[4].vtX = hWidth; nPos[4].vtY = width;
      nPos[5].vtX = 0.0;    nPos[5].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_4:
      nNod  = 7;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = hWidth; nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = 0.0;
      nPos[3].vtX = width;  nPos[3].vtY = hWidth;
      nPos[4].vtX = width;  nPos[4].vtY = width;
      nPos[5].vtX = hWidth; nPos[5].vtY = width;
      nPos[6].vtX = 0.0;    nPos[6].vtY = width;
      break;
    case WLZ_LBT_NODE_CLASS_2D_5:
      nNod  = 8;
      nPos[0].vtX = 0.0;    nPos[0].vtY = 0.0;
      nPos[1].vtX = hWidth; nPos[1].vtY = 0.0;
      nPos[2].vtX = width;  nPos[2].vtY = 0.0;
      nPos[3].vtX = width;  nPos[3].vtY = hWidth;
      nPos[4].vtX = width;  nPos[4].vtY = width;
      nPos[5].vtX = hWidth; nPos[5].vtY = width;
      nPos[6].vtX = 0.0;    nPos[6].vtY = width;
      nPos[7].vtX = 0.0;    nPos[7].vtY = hWidth;
      break;
  }
  /* Rotate the mesh nodes adding the offset from the LBT node's position. */
  switch(rot)
  {
    case 0:
      for(idN = 0; idN < nNod; ++idN)
      {
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtY;
      }
      break;
    case 1:
      for(idN = 0; idN < nNod; ++idN)
      {
	tD0 = nPos[idN].vtX;
	nPos[idN].vtX = lPos.vtX + width - nPos[idN].vtY;
	nPos[idN].vtY = lPos.vtY + tD0;
      }
      break;
    case 2:
      for(idN = 0; idN < nNod; ++idN)
      {
	nPos[idN].vtX = lPos.vtX + width - nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + width - nPos[idN].vtY;
      }
      break;
    case 3:
      for(idN = 0; idN < nNod; ++idN)
      {
	tD0 = nPos[idN].vtX;
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtY;
	nPos[idN].vtY = lPos.vtY + width - tD0;
      }
      break;
  }
  return(nNod);
}

/*!
* \return	Number of nodes for the given LBT domain node face.
* \ingroup	WlzMesh
* \brief	Computes the positions of the mesh nodes for the given
*		face of a 3D LBT domain node.
* \param	nPos			Array for node positions.
* \param	lDom			LBT domain.
* \param	idN			Index of LBT node.
* \param	idF			Index of the face.
* \param	cls			LBT node adjacency class.
* \param	rot			LBT node rotation from class.
*/
static int	WlzCMeshCompLBTFceNodPos3D(WlzDVertex3 *nPos,
				      WlzLBTDomain3D *lDom, int idN,
				      int idF, WlzLBTNodeClass2D cls, int rot)
{
  int		nNod = 0;
  double	tX,
		tY,
  		sz,
		hSz;
  WlzIVertex3	lPos;

  /* TODO Check this function! */

  /* Compute LBT node's position and size / 2. */
  WlzLBTKeyToPos3I((lDom->nodes + idN)->keys, &lPos);
  sz = (double )WlzLBTNodeSz3D(lDom->nodes + idN);
  hSz = sz / 2.0;
  /* Set relative mesh node positions without rotation or offset
   * all for face 0, all as defined in the comments for function
   * WlzCMeshFromBalLBTDom3D(). */
  nPos[0].vtX = hSz; nPos[0].vtY = hSz; nPos[0].vtZ = hSz;   /* Cube centre. */
  nPos[1].vtX = hSz; nPos[1].vtY = 0.0; nPos[1].vtZ = hSz;   /* Face centre. */
  nPos[2].vtX = 0.0; nPos[2].vtY = 0.0; nPos[2].vtZ = 0.0;
  nPos[3].vtX = sz;  nPos[3].vtY = 0.0; nPos[3].vtZ = 0.0;
  nPos[4].vtX = sz;  nPos[4].vtY = 0.0; nPos[4].vtZ = sz;
  nPos[5].vtX = 0.0; nPos[5].vtY = 0.0; nPos[5].vtZ = sz;
  switch(cls)
  {
    case WLZ_LBT_NODE_CLASS_2D_0:
      nNod  = 6;
      break;
    case WLZ_LBT_NODE_CLASS_2D_1:
      nNod  = 7;
      nPos[6].vtX = hSz; nPos[6].vtY = 0.0; nPos[6].vtZ = sz;
      break;
    case WLZ_LBT_NODE_CLASS_2D_2:
      nNod  = 8;
      nPos[6].vtX = hSz; nPos[6].vtY = 0.0; nPos[6].vtZ = sz;
      nPos[7].vtX = sz;  nPos[7].vtY = 0.0; nPos[7].vtZ = hSz;
      break;
    case WLZ_LBT_NODE_CLASS_2D_3:
      nNod  = 8;
      nPos[6].vtX = hSz; nPos[6].vtY = 0.0; nPos[6].vtZ = sz;
      nPos[7].vtX = hSz; nPos[7].vtY = 0.0; nPos[7].vtZ = 0.0;
      break;
    case WLZ_LBT_NODE_CLASS_2D_4:
      nNod  = 9;
      nPos[6].vtX = hSz; nPos[6].vtY = 0.0; nPos[6].vtZ = sz;
      nPos[7].vtX = hSz; nPos[7].vtY = 0.0; nPos[7].vtZ = 0.0;
      nPos[8].vtX = sz;  nPos[8].vtY = 0.0; nPos[8].vtZ = hSz;
      break;
    case WLZ_LBT_NODE_CLASS_2D_5:
      nNod  = 10;
      nPos[6].vtX = hSz; nPos[6].vtY = 0.0; nPos[6].vtZ = sz;
      nPos[7].vtX = hSz; nPos[7].vtY = 0.0; nPos[7].vtZ = 0.0;
      nPos[8].vtX = sz;  nPos[8].vtY = 0.0; nPos[8].vtZ = hSz;
      nPos[9].vtX = 0.0; nPos[9].vtY = 0.0; nPos[9].vtZ = hSz;
      break;
  }
  /* Rotate the mesh nodes to the correct orientation of face 0 about the
   * y axis. */
  switch(rot)
  {
    case 0:
      /* 3---2  ^z  %y
       * |   |  |  /
       * | 0 |  | /
       * |   |  |/
       * 0---1  +--->x
       */
      break;
    case 1:
      /* 3---2    2---1
       * |   |    |   |
       * | 0 |    | 0 |
       * |   |    |   |
       * 0---1    3---0
       */
      for(idN = 2; idN < nNod; ++idN)
      {
	tX = nPos[idN].vtX;
	nPos[idN].vtX = sz - nPos[idN].vtZ;
	nPos[idN].vtZ = tX;
      }
      break;
    case 2:
      /* 3---2    1---0
       * |   |    |   |
       * | 0 |    | 0 |
       * |   |    |   |
       * 0---1    2---3
       */
      for(idN = 2; idN < nNod; ++idN)
      {
	nPos[idN].vtX = sz - nPos[idN].vtX;
	nPos[idN].vtZ = sz - nPos[idN].vtZ;
      }
      break;
    case 3:
      /* 3---2    0---3
       * |   |    |   |
       * | 0 |    | 0 |
       * |   |    |   |
       * 0---1    1---2
       */
      for(idN = 2; idN < nNod; ++idN)
      {
	tX = nPos[idN].vtX;
	nPos[idN].vtX = nPos[idN].vtZ;
	nPos[idN].vtZ = sz - tX;
      }
      break;
  }
  /* Transform the nodes from face 0 to face N and add the node origin. */
  switch(idF)
  {
    case 0:
      /* 3---2  ^ z
       * |   |  |
       * | 0 |  | % y
       * |   |  |/
       * 0---1  +--->x
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtY;
	nPos[idN].vtZ = lPos.vtZ + nPos[idN].vtZ;
      }
      break;
    case 1:
      /* 3---2  ^ z       5---4        ^ y
       * |   |  |         |   |        | 
       * | 0 |  | % y  -> | 1 |        | % z
       * |   |  |/        |   |        |/    
       * 0---1  +---> x   1---0  x <---+
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	tY = nPos[idN].vtY;
	nPos[idN].vtX = lPos.vtX + sz - nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtZ;
	nPos[idN].vtZ = lPos.vtZ + tY;
      }
      break;
    case 2:
      /* 3---2  ^ z         6---5      ^ y
       * |   |  |           |   |      |
       * | 0 |  | % y    -> | 2 |      |
       * |   |  |/          |   |   z  |
       * 0---1  +---> x     2---1  <---+
       *                                \
       *                                 % x
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	tX = nPos[idN].vtX;
	tY = nPos[idN].vtY;
	nPos[idN].vtX = lPos.vtX + sz - tY;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtZ;
	nPos[idN].vtZ = lPos.vtZ + sz - tX;
      }
      break;
    case 3:
      /* 3---2  ^ z         7---6  ^ y
       * |   |  |           |   |  |
       * | 0 |  | % y    -> | 3 |  |
       * |   |  |/          |   |  |
       * 0---1  +---> x     3---2  +--->x
       *                            \
       *                             % z
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	tY = nPos[idN].vtY;
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtX;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtZ;
	nPos[idN].vtZ = lPos.vtZ + sz - tY;
      }
      break;
    case 4:
      /* 3---2  ^ z         4---7  ^ y
       * |   |  |           |   |  |
       * | 0 |  | % y    -> | 4 |  | % x
       * |   |  |/          |   |  |/
       * 0---1  +---> x     0---3  +--->z
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	tX = nPos[idN].vtX;
	tY = nPos[idN].vtY;
	nPos[idN].vtX = lPos.vtX + tY;
	nPos[idN].vtY = lPos.vtY + nPos[idN].vtZ;
	nPos[idN].vtZ = lPos.vtZ + tX;
      }
      break;
    case 5:
      /* 3---2  ^ z         5---6  ^ x
       * |   |  |           |   |  |
       * | 0 |  | % y    -> |   |  |
       * |   |  |/          |   |  |
       * 0---1  +---> x     4---7  +---> z
       *                            \
       *                             % y
       */
      for(idN = 0; idN < nNod; ++idN)
      {
	tX = nPos[idN].vtX;
	nPos[idN].vtX = lPos.vtX + nPos[idN].vtZ;
	nPos[idN].vtY = lPos.vtY + sz - nPos[idN].vtY;
	nPos[idN].vtZ = lPos.vtZ + tX;
      }
      break;
  }
  return(nNod);
}

/*!
* \return	The opposite edge or NULL if there is no opposite edge.
* \ingroup	WlzMesh
* \brief	Finds the opposite edge (to set the opp link) using node
*		nnxt links.
* \param	gEdu			Given edge.
*/
static WlzCMeshEdgU2D *WlzCMeshEdgUseFindOpp2D(WlzCMeshEdgU2D *gEdu)
{
  WlzCMeshEdgU2D *fEdu,
  		*tEdu,
		*oEdu = NULL;

  tEdu = fEdu = gEdu->next->nod->edu;
  do
  {
    if(tEdu->next->nod == gEdu->nod)
    {
      oEdu = tEdu;
      break;
    }
    tEdu = tEdu->nnxt;
  } while(tEdu != fEdu);
  return(oEdu);
}

/*!
* \return	The opposite edge or NULL if there is no opposite edge.
* \ingroup	WlzMesh
* \brief	Finds the opposite edge (to set the opp link) using node
*		nnxt links.
* \param	gEdu			Given edge.
*/
static WlzCMeshEdgU2D5 *WlzCMeshEdgUseFindOpp2D5(WlzCMeshEdgU2D5 *gEdu)
{
  WlzCMeshEdgU2D5 *fEdu,
  		*tEdu,
		*oEdu = NULL;

  tEdu = fEdu = gEdu->next->nod->edu;
  do
  {
    if(tEdu->next->nod == gEdu->nod)
    {
      oEdu = tEdu;
      break;
    }
    tEdu = tEdu->nnxt;
  } while(tEdu != fEdu);
  return(oEdu);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the mesh elements for an LBT node. All pointers
*		must be valid but this is not checked for because this is
*		a static function.
* \param	mesh			The mesh.
* \param	nPos			Positions of the nodes.
* \param	mElm			The new mesh elements.
* \param	mNod			Mesh nodes, non-NULL where the
*					already exist.
* \param	cls			LBT node connectivity class.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmFromLBTNode2D(WlzCMesh2D *mesh,
                                        WlzDVertex2 *nPos,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
					WlzLBTNodeClass2D cls,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  *dstNElm = 0;
  switch(cls)
  {
    case WLZ_LBT_NODE_CLASS_2D_0:
      errNum = WlzCMeshElmsFromLBTNode2D0(mesh, mElm, mNod, nPos, dstNElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_1:
      errNum = WlzCMeshElmsFromLBTNode2D1(mesh, mElm, mNod, nPos, dstNElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_2:
      errNum = WlzCMeshElmsFromLBTNode2D2(mesh, mElm, mNod, nPos, dstNElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_3:
      errNum = WlzCMeshElmsFromLBTNode2D3(mesh, mElm, mNod, nPos, dstNElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_4:
      errNum = WlzCMeshElmsFromLBTNode2D4(mesh, mElm, mNod, nPos, dstNElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_5:
      errNum = WlzCMeshElmsFromLBTNode2D5(mesh, mElm, mNod, nPos, dstNElm);
      break;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the mesh elements for an LBT node. All pointers
*		must be valid but this is not checked for because this is
*		a static function.
* \param	mesh			The mesh.
* \param	nPos			Positions of the nodes.
* \param	mElm			The new mesh elements.
* \param	mNod			Mesh nodes, non-NULL where the
*					already exist.
* \param	cls			LBT node connectivity class.
*/
static WlzErrorNum WlzCMeshElmFromLBTNode3D(WlzCMesh3D *mesh,
                                        WlzDVertex3 *nPos,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
					WlzLBTNodeClass2D cls)
{
  int		nElm = 0;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  switch(cls)
  {
    case WLZ_LBT_NODE_CLASS_2D_0:
      errNum = WlzCMeshElmsFromLBTNode3D0(mesh, mElm, mNod, nPos, &nElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_1:
      errNum = WlzCMeshElmsFromLBTNode3D1(mesh, mElm, mNod, nPos, &nElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_2:
      errNum = WlzCMeshElmsFromLBTNode3D2(mesh, mElm, mNod, nPos, &nElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_3:
      errNum = WlzCMeshElmsFromLBTNode3D3(mesh, mElm, mNod, nPos, &nElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_4:
      errNum = WlzCMeshElmsFromLBTNode3D4(mesh, mElm, mNod, nPos, &nElm);
      break;
    case WLZ_LBT_NODE_CLASS_2D_5:
      errNum = WlzCMeshElmsFromLBTNode3D5(mesh, mElm, mNod, nPos, &nElm);
      break;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 2 mesh elements for a WLZ_LBT_NODE_CLASS_2D_0
*		LBT node.
*		\verbatim
                         nod3                 nod2
                          O                    O
                            +---------------
                           |       0       +
                           |              / /
                           |             / / +
                           |            / /  |
                           |           / /   |
                           |          / /    |
                  elm1 --------      / /     |
                           |       2/ /      |
                           |1      / /       |
                           |      / /2       |
                           |     / /         |
                           |    / /         1|
                           |   / /           |
                           |  / /       --------- elm0
                           + / /             |
                            / +      0       |
                              --------------+
                          O                    O
                         nod0                 nod1
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D0(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[2], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[2], mNod[3], mNod[0], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 2;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_1
*		LBT node.
*		\verbatim
                          nod4              nod3           nod2
			   O                 O              O
                             +--------------   +------------ 
                           |       0        /\       1       
                           |              +/ +\             +
                           |             //   \\            |
                           |            //     \\       -------- elm 1
                   elm2 -------        //       \\          |
                           |          //         \\        0|         
                           |         //           \\        |          
                           |1      2//2           1\\2      |           
                           |       //               \\      |            
                           |      //                 \\     |             
                           |     //                   \\    |              
                           |    //                     \\   |               
                           |   //                       \\  |                
                           |  //                         \+ |                 
                           + /+                 |         \ |                  
                            /              0    |           |
                             -------------------|---------+  
		          O                     |            O
                         nod0                 elm0          nod1
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D1(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[3], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[0], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 3;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 4 mesh elements for a WLZ_LBT_NODE_CLASS_2D_2
*		LBT node.
*		\verbatim
                          nod5              nod4           nod3
			   O                 O              O
                             +--------------   +------------ 
                           |        0      +/  +\     1     +
                           |              //     \\         |
                           |             //        \\      0|
                           |            //          1\\2  ----- elm1  
                   elm2 ------         //              \\   |
                           |          //                 \+ |         
                           |         //      elm3           O nod2     
                           |1      2//2                                 
                           |       //                   +/  +            
                           |      //                //      |             
                           |     //             //          |              
                           |    //         0//2             |               
                           |   //       //                 1|                
                           |  //    //                      |                 
                           + /+ /+                          |                  
                                              0 |           |
                              ------------------|---------+  
		          O                     |            O
                         nod0                 elm0          nod1
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D2(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[2], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[2], mNod[3], mNod[4], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[4], mNod[5], mNod[0], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[2], mNod[4], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 4;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_3
*		LBT node.
*		\verbatim
                          nod5             nod4             nod3
			   O                O                O
                             +-------------    +------------- 
                           |       0         |       0        
                           |                +|               +
                           |             +/ ||             +/|
                           |            //  ||            // |         
                           |    elm3   //   ||    elm2   //  |
                           |          //    ||          //   |         
                           |         //     ||         //    |          
                           |1      2//      ||1      2//     |           
                           |       //       ||       //      |            
                           |      //2      1||      //       |             
                           |     //         ||     //2      1|              
                           |    //          ||    //         |               
                           |   //           ||   //          |                
                           |  //   elm0     ||  //  elm1     |                 
                           + /+             |+ //            |                  
                                    0       |        0       |
                              -----------+    -------------+  
		          O                 O                O
                         nod0              nod1             nod2
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D3(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[4], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[1], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[4], mNod[5], mNod[0], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 4;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_4
*		LBT node.
*		\verbatim
                          nod6             nod5             nod4
			   O                O                O
                             +-------------    +------------- 
                           |       0         | +\     1      +
                           |              +/+|  \\           |
                           |             // ||    \\      ------ elm2
                           |            //  ||      \\2      |         
                           |    elm3   //   ||      1 \\    0|
                           |          //    ||          \\   |         
                           |         //     ||            \+            
                           |1      2//      ||   elm4        O nod3      
                           |       //2      ||             +/              
                           |      //      1 ||2          //  +             
                           |     //         ||         //    |              
                           |    //          ||      0//      |               
                           |   //           ||     //2      1|                
                           |  //   elm0     ||   //          |                 
                           | /+             |+ /+         ------ elm1           
                                    0       |        0       |
                              -----------+    ------------+  
		           O                O                O
                          nod0             nod1             nod2
		       
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D4(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[5], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[5], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[5], mNod[6], mNod[0], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[4] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[3], mNod[5], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 5;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 3 mesh elements for a WLZ_LBT_NODE_CLASS_2D_5
*		LBT node.
*		\verbatim
                          nod6             nod5             nod4
			   O                O                O
                             +-------------    +------------- 
                           |       0     +/  | +\      1     +
                           |1          //   +|  \\          0|
                           |        2//     ||    \\         |
                     elm3 ---      //2      ||      \\2    ---- elm2   
                           |     //         ||       1\\     |
                           +   //           ||          \\   |         
                             /+             ||            \+            
                      nod7 O       elm4    1||2  elm5        O nod3      
                             +              ||             +/              
                           |  \\            ||           //  +             
                           |    \\          ||         //    |              
                           |      \\0       ||      0//      |               
                           |2     1 \\      ||     //2      1|                
                           |          \\    ||   //          |                 
                           +            \+  |+ /+            |                  
                                 | 0        |        | 0     |
                              ---|-------+    -------|----+  
		           O     |          O        |       O
                          nod0             nod1             nod2
		                elm0                elm1
		\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for number of
					elements.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode2D5(WlzCMesh2D *mesh,
					WlzCMeshElm2D **mElm,
					WlzCMeshNod2D **mNod,
				        WlzDVertex2 *nPos,
					int *dstNElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[0] = WlzCMeshNewElm2D(mesh, mNod[0], mNod[1], mNod[7], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[1] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[2], mNod[3], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[2] = WlzCMeshNewElm2D(mesh, mNod[3], mNod[4], mNod[5], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[3] = WlzCMeshNewElm2D(mesh, mNod[5], mNod[6], mNod[7], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[4] = WlzCMeshNewElm2D(mesh, mNod[7], mNod[1], mNod[5], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    mElm[5] = WlzCMeshNewElm2D(mesh, mNod[1], mNod[3], mNod[5], 0, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = 6;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 4 mesh elements for a WLZ_LBT_NODE_CLASS_2D_0
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             / \                                             
                            /   \                                            
                           /     \                                           
                          /       \                                          
                         /         \                                         
                        /    f1     \                                        
                       /             \                                       
                    n5o---------------on4                      
                     /|\     f0      /|\                                     
                    / | \           / | \                                    
                   /  |  \  elm2   /  |  \                               
                  /   |   \       /   |   \                              
                 /    |    \     /    |    \                            
                /     |     \   /     |     \                          
               /      |      \ /      |      \                        
            n0o       |  elm1 o elm3  |       on0                    
               \  f1  |      /|\      |      /                      
                \     | f0  / | \  f0 |     /                            
                 \    |    /  n1 \    |    /                               
                  \   |   /       \   |   /                           
                   \  |  /  elm0   \  |  /                      
                    \ | /           \ | /                                    
                     \|/     f0      \|/                             
                    n2o---------------on3                          
                       \             /                      
                        \    f1     /                                         
                         \         /                             
                          \       /                             
                           \     /                             
                            \   /                             
                             \ /                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D0(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[4][4] =
                {
		  {3, 2, 0, 1},
		  {2, 5, 0, 1},
		  {5, 4, 0, 1},
		  {4, 3, 0, 1}
		};
  const int	nElm = 4;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], 0, &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 5 mesh elements for a WLZ_LBT_NODE_CLASS_2D_1
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             /|\                                             
                            / | \                                            
                           /  |  \                                           
                          / f1|f1 \                                          
                         /    |    \                                         
                        /     | n6  \                                        
                       /      |/     \                                       
                    n5o-------o-------on4                      
                     /|\      |      /|\                                     
                    / | \ elm2|elm3 / | \                                    
                   /  |  \    |    /  |  \                               
                  /   |   \ f0|f0 /   |   \                              
                 /    |    \  |  /    |    \                            
                /     |     \ | /     |     \                          
               /      |      \|/      |      \                        
            n0o       |  elm1 o elm4  |       on0                    
               \  f1  |      /|\      |      /                      
                \     | f0  / | \  f0 |     /                            
                 \    |    /  n1 \    |    /                               
                  \   |   /       \   |   /                           
                   \  |  /  elm0   \  |  /                      
                    \ | /           \ | /                                    
                     \|/     f0      \|/                             
                    n2o---------------on3                          
                       \             /                      
                        \    f1     /                                         
                         \         /                             
                          \       /                             
                           \     /                             
                            \   /                             
                             \ /                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D1(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[5][4] =
                {
		  {3, 2, 0, 1},
		  {2, 5, 0, 1},
		  {5, 6, 0, 1},
		  {6, 4, 0, 1},
		  {4, 3, 0, 1}
		};
  const int	nElm = 5;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], 0, &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 6 mesh elements for a WLZ_LBT_NODE_CLASS_2D_2
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             /|\                                             
                            / | \                                            
                           /  |  \                                           
                          / f1|f1 \                                          
                         /    |    \                                         
                        /     | n6  \                                        
                       /      |/     \                                       
                    n5o-------o-------on4                      
                     /|\      |      /|\                                     
                    / | \ elm2|elm3 / | \                                    
                   /  |  \    |    /  |  \                               
                  /   |   \ f0|f0 /   |f1 \                              
                 /    |    \  |  /    |    \                            
                /     |     \ | / elm4|     \                          
               /      |      \|/f0    |      \                        
            n0o       |  elm1 o-------o-------on0                    
               \  f1  |      /|\f0    |\     /                      
                \     | f0  / | \ elm5| n7  /                            
                 \    |    /  n1 \    |    /                               
                  \   |   /       \   |f1 /                           
                   \  |  /  elm0   \  |  /                      
                    \ | /           \ | /                                    
                     \|/     f0      \|/                             
                    n2o---------------on3                          
                       \             /                      
                        \    f1     /                                         
                         \         /                             
                          \       /                             
                           \     /                             
                            \   /                             
                             \ /                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D2(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[6][4] =
                {
		  {3, 2, 0, 1},
		  {2, 5, 0, 1},
		  {5, 6, 0, 1},
		  {6, 4, 0, 1},
		  {4, 7, 0, 1},
		  {7, 3, 0, 1}
		};
  const int	nElm = 6;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], 0, &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 6 mesh elements for a WLZ_LBT_NODE_CLASS_2D_3
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             /|\                                             
                            / | \                                            
                           /  |  \                                           
                          / f1|f1 \                                          
                         /    |    \                                         
                        /     | n6  \                                        
                       /      |/     \                                       
                    n5o-------o-------on4                      
                     /|\      |      /|\                                     
                    / | \ elm3|elm4 / | \                                    
                   /  |  \    |    /  |  \                               
                  /   |   \ f0|f0 /   |f1 \                              
                 /    |    \  |  /    |    \                            
                /     |     \ | /  f0 |     \
               /      |      \|/      |      \                        
            n0o       |  elm2 o-n1    |       on0                    
               \  f1  |      /|\      |      /                      
                \     | f0  / | \ elm5|     /                            
                 \    |    /  |  \    |    /                               
                  \   |   / f0|f0 \   |   /                           
                   \  |  /    |    \  |  /                      
                    \ | / elm1|elm0 \ | /                                    
                     \|/      |      \|/                             
                    n2o-------o-------on3                          
                       \      |\      /                      
                        \     | n7  /                                         
                         \    |    /                             
                          \ f1|f1 /                             
                           \  |  /                             
                            \ | /                             
                             \|/                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D3(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[6][4] =
                {
		  {3, 7, 0, 1},
		  {7, 2, 0, 1},
		  {2, 5, 0, 1},
		  {5, 6, 0, 1},
		  {6, 4, 0, 1},
		  {4, 3, 0, 1}
		};
  const int	nElm = 6;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], 0, &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 7 mesh elements for a WLZ_LBT_NODE_CLASS_2D_4
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             /|\                                             
                            / | \                                            
                           /  |  \                                           
                          / f1|f1 \                                          
                         /    |    \                                         
                        /     | n6  \                                        
                       /      |/     \                                       
                    n5o-------o-------on4                      
                     /|\      |      /|\                                     
                    / | \ elm3|elm4 / | \                                    
                   /  |  \    |    /  |  \                               
                  /   |   \ f0|f0 / f0|f1 \                              
                 /    |    \  |  /    |    \                            
                /     |     \ | / elm5| n8  \
               /      |      \|/n1    |/     \                        
            n0o       |  elm2 o-------o-------on0                    
               \  f1  |      /|\      |      /                      
                \     | f0  / | \ elm6|     /                            
                 \    |    /  |  \    |    /                               
                  \   |   / f0|f0 \ f0|f1 /                           
                   \  |  /    |    \  |  /                      
                    \ | / elm1|elm0 \ | /                                    
                     \|/      |      \|/                             
                    n2o-------o-------on3                          
                       \      |\      /                      
                        \     | n7  /                                         
                         \    |    /                             
                          \ f1|f1 /                             
                           \  |  /                             
                            \ | /                             
                             \|/                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D4(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[7][4] =
                {
		  {3, 7, 0, 1},
		  {7, 2, 0, 1},
		  {2, 5, 0, 1},
		  {5, 6, 0, 1},
		  {6, 4, 0, 1},
		  {4, 8, 0, 1},
		  {8, 3, 0, 1}
		};
  const int	nElm = 7;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], 0, &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Creates the 8 mesh elements for a WLZ_LBT_NODE_CLASS_2D_5
*		face of a 3D LBT node.
\verbatim
                              n0                                               
                              o                                               
                             /|\                                             
                            / | \                                            
                           /  |  \                                           
                          / f1|f1 \                                          
                         /    |    \                                         
                        /     | n6  \                                        
                       /      |/     \                                       
                    n5o-------o-------on4                      
                     /|\      |      /|\                                     
                    / | \ elm4|elm5 / | \                                    
                   /  |  \    |    /  |  \                               
                  / f1|f0 \ f0|f0 / f0|f1 \                              
                 /    |    \  |  /    |    \                            
                /  n9 |elm3 \ | / elm6| n8  \
               /     \|      \|/n1    |/     \                        
            n0o-------o-------o-------o-------on0                    
               \      |      /|\      |      /                      
                \     |elm2 / | \ elm7|     /                            
                 \    |    /  |  \    |    /                               
                  \ f1|f0 / f0|f0 \ f0|f1 /                           
                   \  |  /    |    \  |  /                      
                    \ | / elm1|elm0 \ | /                                    
                     \|/      |      \|/                             
                    n2o-------o-------on3                          
                       \      |\      /                      
                        \     | n7  /                                         
                         \    |    /                             
                          \ f1|f1 /                             
                           \  |  /                             
                            \ | /                             
                             \|/                               
                              o                                              
			      n0
\endverbatim
* \param	mesh			The mesh.
* \param	mElm			The new mesh elements.
* \param	mNod			Matched nodes, NULL if don't exist.
* \param	nPos			Node positions.
* \param	dstNElm			Destination pointer for the number of
* 					new mesh elements, nust be vaild.
*/
static WlzErrorNum WlzCMeshElmsFromLBTNode3D5(WlzCMesh3D *mesh,
					WlzCMeshElm3D **mElm,
					WlzCMeshNod3D **mNod,
				        WlzDVertex3 *nPos,
					int *dstNElm)
{
  int		idE;
  const int	nodTbl[8][4] =
                {
		  {3, 7, 0, 1},
		  {7, 2, 0, 1},
		  {2, 9, 0, 1},
		  {9, 5, 0, 1},
		  {5, 6, 0, 1},
		  {6, 4, 0, 1},
		  {4, 8, 0, 1},
		  {8, 3, 0, 1}
		};
  const int	nElm = 8;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Create new mesh elements using the nodes. */
  idE = 0;
  while((errNum == WLZ_ERR_NONE) && (idE < nElm))
  {
    mElm[idE] = WlzCMeshNewElm3D(mesh, mNod[nodTbl[idE][0]],
                                       mNod[nodTbl[idE][1]],
				       mNod[nodTbl[idE][2]],
				       mNod[nodTbl[idE][3]], 0, &errNum);
    ++idE;
  }
  if(errNum == WLZ_ERR_NONE)
  {
    *dstNElm = nElm;
  }
  return(errNum);
}

/*!
* \return 	A new object with the same domain as the given object but
* 		with 3D normals for it's indexed values.
* \ingroup	WlzMesh
* \brief	Computes the normals at the nodes of the given mesh.
* 		The normals are computed for each node by computing the
* 		area and normal of each face which uses the node and then
* 		using a linear combination of the face normals with a
* 		weight proportional to the area.
*
* 		\f[
 		   n = \sum_{i\in E} {A_i n_i}
  		\f]
* 		where \f$A_i\f$ is the area of the i'th element \f$n_i\f$
* 		is it normal and \f$E\f$ is the set of elements that use
* 		the node.
* \param	gObj			Given 2D5 conforming mesh object.
* \param	nrmFlg			All normals will have unit length if
* 					this flag is non-zero.
* \param	dstErr			Destination error pointer, may be NULL.
*/
WlzObject	*WlzCMeshComputeNormalsIxv2D5(WlzObject *gObj, int nrmFlg,
					      WlzErrorNum *dstErr)
{
  WlzDVertex3	*norm = NULL;
  WlzObject	*nObj = NULL;
  WlzIndexedValues *nIxv = NULL;
  WlzCMesh2D5	*mesh;
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(gObj == NULL)
  {
    errNum = WLZ_ERR_OBJECT_NULL;
  }
  else if(gObj->type != WLZ_CMESH_2D5)
  {
    errNum = WLZ_ERR_OBJECT_TYPE;
  }
  else if((mesh = gObj->domain.cm2d5) == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if((mesh->res.nod.numEnt < 3) || (mesh->res.elm.numEnt < 1))
  {
    errNum = WLZ_ERR_DOMAIN_DATA;
  }
  else if(((norm = (WlzDVertex3 *)AlcMalloc(sizeof(WlzDVertex3) *
                                            mesh->res.elm.maxEnt)) == NULL))
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  else
  {
    int	dim = 3;
    nIxv = WlzMakeIndexedValues(gObj, 1, &dim, WLZ_GREY_DOUBLE,
                                WLZ_VALUE_ATTACH_NOD, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    WlzValues val;

    val.x = nIxv;
    nObj = WlzMakeMain(WLZ_CMESH_2D5, gObj->domain, val, NULL, NULL, &errNum);
  }
  if(errNum == WLZ_ERR_NONE)
  {
    int	idE,
    	idN,
	maxIdxBuf = 0;
    int *idxBuf = NULL;

    /* Compute area vectors these will be twice the area x normal. */
    for(idE = 0; idE < mesh->res.elm.maxEnt; ++idE)
    {
      WlzCMeshElm2D5 *elm;
      WlzDVertex3 v[3];

      elm = (WlzCMeshElm2D5 *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
	v[0] = elm->edu[0].nod->pos;
	v[1] = elm->edu[1].nod->pos;
	v[2] = elm->edu[2].nod->pos;
	WLZ_VTX_3_SUB(v[0], v[1], v[0]);
	WLZ_VTX_3_SUB(v[1], v[2], v[1]);
	WLZ_VTX_3_CROSS(norm[idE], v[0], v[1]);
      }
    }
    /* Compute the node normals from the sum of the element area vectors. */
    for(idN = 0; idN < mesh->res.nod.maxEnt; ++idN)
    {
      WlzCMeshNod2D5 *nod;

      nod = (WlzCMeshNod2D5 *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	int nE;
	WlzDVertex3 nrm;
	double *n;

	WLZ_VTX_3_ZERO(nrm);
        nE = WlzCMeshNodRingElmIndices2D5(nod, &maxIdxBuf, &idxBuf, &errNum);
	for(idE = 0; idE < nE; ++idE)
	{
	  WLZ_VTX_3_ADD(nrm, nrm, norm[idE]);
	}
	if(nrmFlg == 0)
	{
	  double l;

	  l = WLZ_VTX_3_LENGTH(nrm);
	  if(l > DBL_EPSILON)
	  {
	    l = 1.0 / l;
	    WLZ_VTX_3_SCALE(nrm, nrm, l);
	  }
	  else
	  {
	    l = 1.0 / ALG_M_SQRT3;
	    WLZ_VTX_3_SET(nrm, l, l, l);
	  }
	}
        n = WlzIndexedValueGet(nIxv, idN);
	n[0] = nrm.vtX;
	n[1] = nrm.vtY;
	n[2] = nrm.vtZ;
      }
    }
    AlcFree(idxBuf);
  }
  AlcFree(norm);
  if(errNum != WLZ_ERR_NONE)
  {
    if(nObj)
    {
      (void )WlzFreeObj(nObj);
      nObj = NULL;
    }
    else if(nIxv != NULL)
    {
      (void )WlzFreeIndexedValues(nIxv);
    }
  }
  if(dstErr != NULL)
  {
    *dstErr = errNum;
  }
  return(nObj);
}

/*!
* \ingroup      WlzTransform
* \brief	Debuging function for 2D mesh output in VTK format.
* \param	fP			Given file pointer.
* \param	mesh			Given mesh.
*/
void		WlzCMeshDbgOutVTK2D(FILE *fP, WlzCMesh2D *mesh)
{
  int		idE,
		idN,
		nElm,
		nVElm,
  		nNod;
  WlzCMeshElm2D  *elm;
  WlzCMeshNod2D	*nod;

  if(mesh && (mesh->type == WLZ_CMESH_2D) &&
    ((nNod = mesh->res.nod.maxEnt) > 0) &&
    ((nElm = mesh->res.elm.maxEnt) > 0))
  {
    (void )fprintf(fP,
		   "# vtk DataFile Version 1.0\n"
		   "WlzCMesh2D 2D\n"
		   "ASCII\n"
		   "DATASET POLYDATA\n"
		   "POINTS %d float\n",
		   nNod);
    /* Output all nodes but use (0, 0, 0) for those that are invalid. */
    for(idN = 0; idN < nNod; ++idN)
    {
      nod = (WlzCMeshNod2D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	(void )fprintf(fP, "%g %g 0\n",
		       nod->pos.vtX, nod->pos.vtY);
      }
      else
      {
	(void )fprintf(fP, "0 0 0\n");
      }
    }
    /* Output all valid mesh element simplices. */
    nVElm = 0;
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
        ++nVElm;
      }
    }
    (void )fprintf(fP, "POLYGONS %d %d\n",
		   nVElm, nVElm * 4);
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzCMeshElm2D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
	(void )fprintf(fP, "3 %d %d %d\n",
		       elm->edu[0].nod->idx, elm->edu[1].nod->idx, 
		       elm->edu[2].nod->idx);
      }
    }
  }
}

/*!
* \ingroup      WlzTransform
* \brief	Debuging function for 3D mesh output in VTK format.
* \param	fP			Given file pointer.
* \param	mesh			Given mesh.
*/
void		WlzCMeshDbgOutVTK3D(FILE *fP, WlzCMesh3D *mesh)
{
  int		idE,
		idF,
		idN,
		nElm,
		nVSpx,
  		nNod;
  WlzCMeshElm3D  *elm;
  WlzCMeshFace	*fce;
  WlzCMeshNod3D	*nod;

  if(mesh && (mesh->type == WLZ_CMESH_3D) &&
    ((nNod = mesh->res.nod.maxEnt) > 0) &&
    ((nElm = mesh->res.elm.maxEnt) > 0))
  {
    (void )fprintf(fP,
		   "# vtk DataFile Version 1.0\n"
		   "WlzCMesh3D 3D\n"
		   "ASCII\n"
		   "DATASET POLYDATA\n"
		   "POINTS %d float\n",
		   nNod);
    /* Output all nodes but use (0, 0, 0) for those that are invalid. */
    for(idN = 0; idN < nNod; ++idN)
    {
      nod = (WlzCMeshNod3D *)AlcVectorItemGet(mesh->res.nod.vec, idN);
      if(nod->idx >= 0)
      {
	(void )fprintf(fP, "%g %g %g\n",
		       nod->pos.vtX, nod->pos.vtY, nod->pos.vtZ);
      }
      else
      {
	(void )fprintf(fP, "0 0 0\n");
      }
    }
    /* Output the faces of all valid mesh element simplices, but only one
     * face of an opposite face pair. This is done to reduce the number of
     * triangles in the output. */
    nVSpx = 0;
    /* First find number of faces. */
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
        for(idF = 0; idF < 4; ++idF)
	{
	  fce = elm->face + idF;
	  if((fce->opp == NULL) ||
	     (fce->opp == fce) ||
	     (fce->elm->idx < fce->opp->elm->idx))
	  {
            ++nVSpx;
	  }
	}
      }
    }
    /* Output faces using the same code as above to select the faces. */
    (void )fprintf(fP, "POLYGONS %d %d\n",
		   nVSpx, nVSpx * 4);
    for(idE = 0; idE < nElm; ++idE)
    {
      elm = (WlzCMeshElm3D *)AlcVectorItemGet(mesh->res.elm.vec, idE);
      if(elm->idx >= 0)
      {
        for(idF = 0; idF < 4; ++idF)
	{
	  fce = elm->face + idF;
	  if((fce->opp == NULL) ||
	     (fce->opp == fce) ||
	     (fce->elm->idx < fce->opp->elm->idx))
	  {
	    (void )fprintf(fP, "3 %d %d %d\n",
			   fce->edu[0].nod->idx, fce->edu[1].nod->idx, 
			   fce->edu[2].nod->idx);
	  }
	}
      }
    }
  }
}

/*!
* ingroup	WlzTransform
* \brief	Debuging function for mesh output in VTK format.
* \param	fP			Given file pointer.
* \param	mesh			Given mesh.
*/
void		WlzCMeshDbgOutVTK(FILE *fP, WlzCMeshP mesh)
{
  if(mesh.v)
  {
    switch(mesh.m2->type)
    {
      case WLZ_CMESH_2D:
        WlzCMeshDbgOutVTK2D(fP, mesh.m2);
	break;
      case WLZ_CMESH_3D:
        WlzCMeshDbgOutVTK3D(fP, mesh.m3);
        break;
      default:
        break;
    }
  }
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Fuses the given element in the mesh.
* \param	mesh			The mesh.
* \param	gElm			Element to be removed by fusion.
*/
WlzErrorNum	WlzCMeshElmFuse2D(WlzCMesh2D *mesh, WlzCMeshElm2D *gElm)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  if(mesh == NULL)
  {
    errNum = WLZ_ERR_DOMAIN_NULL;
  }
  else if(mesh->type != WLZ_CMESH_2D)
  {
    errNum = WLZ_ERR_DOMAIN_TYPE;
  }
  else if(gElm == NULL)
  {
    errNum = WLZ_ERR_PARAM_NULL;
  }
  else if(gElm->idx < 0)
  {
    errNum = WLZ_ERR_PARAM_DATA;
  }
  else
  {
    int		idN,
    		cnt = 0,
  		msk = 0;

    for(idN = 0; idN < 3; ++idN)
    {
      int	t;
      WlzCMeshEdgU2D *e;

      e = &(gElm->edu[0]);
      t = (e->opp != NULL) && (e->opp != e);
      cnt += t;
      msk |= t << idN;
    }
    switch(cnt)
    {
      case 2:
        errNum = WlzCMeshElmFuse2D2(mesh, gElm, msk);
	break;
      case 3:
        errNum = WlzCMeshElmFuse2D3(mesh, gElm);
	break;
      default:
        break;
    }
  }
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Fuses the given element in the mesh where the element has
* 		two edge neighbours.
* \param	mesh			The mesh.
* \param	gElm			Element to be removed by fusion.
* \param	edgMsk			Element edge mask.
*/
static WlzErrorNum WlzCMeshElmFuse2D2(WlzCMesh2D *mesh, WlzCMeshElm2D *gElm,
				      int edgMsk)
{
  WlzErrorNum	errNum = WLZ_ERR_NONE;
  
  /* This is unimplemented and simply returns no error. */
  return(errNum);
}

/*!
* \return	Woolz error code.
* \ingroup	WlzMesh
* \brief	Fuses the given element in the mesh where the element has all
* 		three edge neighbours. It probably works for only 2 edge
* 		neighbours too, but is not optimal.
* \param	mesh			The mesh.
* \param	gElm			Element to be removed by fusion.
*/
static WlzErrorNum WlzCMeshElmFuse2D3(WlzCMesh2D *mesh, WlzCMeshElm2D *gElm)
{
  int		idL,
  		idM,
  		idN,
  		maxNEdu,
		nEdu = 0,
		nDElm = 0,
		nBEdu = 0,
		nBNod = 0,
		nTElm = 0;
  WlzCMeshEdgU2D *edu[4];
  WlzCMeshEdgU2D **bEdu = NULL; /* Array of boundary edge uses (inside the
  				 * elements to be deleted. */
  WlzDVertex2	*bPos = NULL;  /* Array of boundary node position pairs. */
  WlzCMeshNod2D	**bNod = NULL;  /* Array for boundary nodes. */
  WlzCMeshElm2D **dElm = NULL; /* Array of elements within the boundary to
  				* be deleted and replaced. */
  int		*tElmIdx = NULL; /* Indices of the boundary polygon positions
  				  * that retriangulate the polygon. */
  WlzErrorNum	errNum = WLZ_ERR_NONE;

  /* Collect edge neighbor elements.
   * Compute upper limit for the number of nodes and elements that surround
   * the nodes of the given element's nodes. Then allocate a neighbouring
   * edge use array. */
  for(idN = 0; idN < 3; ++idN)
  {
    edu[0] = edu[1] = gElm->edu[idN].nod->edu;
    do
    {
      ++nEdu;
      edu[1] = edu[1]->nnxt;
    } while(edu[0] != edu[1]);
  }
  maxNEdu = 3 * nEdu;
  if(((dElm = (WlzCMeshElm2D **)
              AlcCalloc(maxNEdu, sizeof(WlzCMeshElm2D *))) == NULL) ||
     ((bEdu = (WlzCMeshEdgU2D **)
              AlcCalloc(maxNEdu, sizeof(WlzCMeshEdgU2D *))) == NULL) ||
     ((bPos = (WlzDVertex2 *)
              AlcCalloc(maxNEdu, sizeof(WlzDVertex2))) == NULL) ||
     ((bNod = (WlzCMeshNod2D **)
     	      AlcCalloc(maxNEdu, sizeof(WlzCMeshNod2D *))) == NULL))
  {
    errNum = WLZ_ERR_MEM_ALLOC;
  }
  if(errNum == WLZ_ERR_NONE)
  {
   /* Collect all edge uses of all elements that use a node of the
    * given element and build the deletion element array. */
    idL = 0;
    for(idN = 0; idN < 3; ++idN)
    {
      edu[0] = gElm->edu[idN].nod->edu;
      edu[1] = edu[0];
      do
      {
	int	add = 1;

	for(idM = 0; idM < nDElm; ++idM)
	{
	  if(edu[1]->elm == dElm[idM])
	  {
	    add = 0;
	    break;
	  }
	}
	if(add)
	{
	  bEdu[idL++] = edu[1];
	  bEdu[idL++] = edu[1]->next;
	  bEdu[idL++] = edu[1]->next->next;
	  dElm[nDElm++] = edu[1]->elm;
	}
	edu[1] = edu[1]->nnxt;
      } while(edu[0] != edu[1]);
    }
    /* Remove all edge uses from the boundary edge array which
     * have an opposite edge use and that opposite edge use is used
     * by an element in the deletion array. */
    idL = 0;
    for(idN = 0; idN < maxNEdu; ++idN)
    {
      edu[0] = bEdu[idN];
      if(edu[0])
      {
        int	keep = 1;

	edu[1] = edu[0]->opp;
	if((edu[1] == NULL) || (edu[1] == edu[0]))
	{
	  keep = 1;
	}
	else
	{
	  for(idM = 0; idM < nDElm; ++idM)
	  {
	    if(edu[1]->elm == dElm[idM])
	    {
	      keep = 0;
	      break;
	    }
	  }
	}
	if(keep)
	{
	  bEdu[idL++] = edu[0];
	}
      }
    }
    nBEdu = idL;
    /* Sort the edge uses to form a loop of node positions. */
    bPos[0] = bEdu[0]->nod->pos;
    for(idM = 0; idM < (nBEdu - 1); ++idM)
    {
      WlzCMeshNod2D *nNod;

      nNod = bEdu[idM]->next->nod;
      for(idN = idM + 1; idN < nBEdu; ++idN)
      {
        if(bEdu[idN]->nod == nNod)
	{
	  edu[0] = bEdu[idM + 1];
	  bEdu[idM + 1] = bEdu[idN];
	  bEdu[idN] = edu[0];
	  bPos[nBNod++] = nNod->pos;
	  break;
	}
      }
    }
  }
  /* Delete the elements connected to the nodes of the given element. */
  for(idN = 0; (errNum == WLZ_ERR_NONE) && (idN < nDElm); ++idN)
  {
    errNum = WlzCMeshDelElm2D(mesh, dElm[idN]);
  }
  /* Triangulate the empty polygon. */
  if(errNum == WLZ_ERR_NONE)
  {
    errNum = WlzGeomPolyTriangulate2D(nBNod, bPos, &nTElm, &tElmIdx);
  }
  /* For each of the boundary node positions make sure that a node
   * exists and gather the nodes. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idN = 0; idN < nBNod; ++idN)
    {
      if((bNod[idN] = WlzCMeshMatchNod2D(mesh, bPos[idN],
                                         WLZ_MESH_TOLERANCE)) == NULL)
      {
        bNod[idN] = WlzCMeshNewNod2D(mesh, bPos[idN], &errNum);
	if(errNum != WLZ_ERR_NONE)
	{
	  break;
	}
      }
    }
  }
  /* Create the new mesh elements filling the boundary polygon. */
  if(errNum == WLZ_ERR_NONE)
  {
    for(idN = 0; idN < nTElm; ++idN)
    {
      int	*idx;

      idx = tElmIdx + (idN * 3);
      (void )WlzCMeshNewElm2D(mesh,
                              bNod[idx[0]], bNod[idx[1]], bNod[idx[2]],
			      1, &errNum);
      if(errNum != WLZ_ERR_NONE)
      {
	break;
      }
    }
  }
  AlcFree(bEdu);
  AlcFree(bPos);
  AlcFree(bNod);
  AlcFree(dElm);
  AlcFree(tElmIdx);
  return(errNum);
}
